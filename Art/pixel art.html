<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>PixelForge Studio Pro - Next Level Pixel Art</title> <style> body { margin: 0; background: #121212; color: #fff; font-family: "Inter", sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden; } header { background: #0d0d0d; padding: 10px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5); } header h1 { font-size: 1.1em; margin: 0; color: #00ffc8; } header button { background: #222; border: none; color: #fff; padding: 8px 12px; margin: 0 4px; border-radius: 4px; transition: background 0.2s; } header button:hover { background: #00ffc8; color: #000; } #canvas-container { flex: 1; display: flex; justify-content: center; align-items: center; background: repeating-conic-gradient(#444 0% 25%, transparent 0% 50%) 50% / 20px 20px; position: relative; } canvas { image-rendering: pixelated; background: transparent; border: 1px solid #555; touch-action: none; } #toolbar { background: #0d0d0d; display: flex; justify-content: space-around; align-items: center; padding: 10px; border-top: 1px solid #333; } #toolbar input, #toolbar select { background: #222; color: #fff; border: 1px solid #444; border-radius: 4px; padding: 4px; } #layers { position: absolute; top: 10px; right: 10px; background: rgba(20,20,20,0.95); border: 1px solid #333; border-radius: 6px; padding: 8px; font-size: 0.9em; max-height: 80%; overflow-y: auto; } .layer-item { display: flex; justify-content: space-between; align-items: center; margin: 4px 0; padding: 2px 4px; border-radius: 3px; } .layer-item.active { background: #00ffc8; color: #000; } .layer-item button { background: #333; border: none; color: #fff; padding: 2px 6px; border-radius: 3px; } #animControls { position: absolute; bottom: 10px; right: 10px; background: rgba(20,20,20,0.9); border: 1px solid #333; border-radius: 6px; padding: 8px; display: flex; gap: 6px; } #animControls button { background: #333; border: none; color: #fff; padding: 4px 8px; border-radius: 4px; } </style> </head> <body> <header> <h1>PixelForge Studio Pro</h1> <div> <button id="newBtn">New</button> <button id="saveBtn">Save</button> <button id="exportBtn">Export PNG</button> </div> </header> <div id="canvas-container"> <canvas id="pixelCanvas" width="256" height="256"></canvas> <div id="layers"></div> <div id="animControls"> <button id="addFrameBtn">+ Frame</button> <button id="playAnimBtn">â–¶</button> </div> </div> <div id="toolbar"> <label>Tool:</label> <select id="toolSelect"> <option value="brush">Brush</option> <option value="eraser">Eraser</option> <option value="fill">Fill</option> </select> <label>Color:</label> <input type="color" id="colorPicker" value="#ff0000"> <label>Brush:</label> <input type="number" id="brushSize" min="1" max="10" value="1"> <button id="addLayerBtn">+ Layer</button> </div> <script> const canvas = document.getElementById('pixelCanvas'); const ctx = canvas.getContext('2d', { willReadFrequently: true }); ctx.imageSmoothingEnabled = false; let drawing = false; let color = document.getElementById('colorPicker').value; let brushSize = parseInt(document.getElementById('brushSize').value); let tool = document.getElementById('toolSelect').value; let state = { files: {}, currentFile: "pixel_art", layers: [], activeLayer: 0, frames: [], currentFrame: 0, playing: false }; function createLayer() { const layer = document.createElement('canvas'); layer.width = canvas.width; layer.height = canvas.height; const layerCtx = layer.getContext('2d', { willReadFrequently: true }); layerCtx.imageSmoothingEnabled = false; state.layers.push(layer); updateLayerUI(); drawComposite(); } function updateLayerUI() { const layersDiv = document.getElementById('layers'); layersDiv.innerHTML = ''; state.layers.forEach((_, i) => { const div = document.createElement('div'); div.className = 'layer-item' + (i === state.activeLayer ? ' active' : ''); div.innerHTML = `Layer ${i+1} <button data-index="${i}">X</button>`; div.addEventListener('click', () => { state.activeLayer = i; updateLayerUI(); }); div.querySelector('button').addEventListener('click', e => { e.stopPropagation(); state.layers.splice(i,1); if (state.activeLayer >= state.layers.length) state.activeLayer = state.layers.length-1; updateLayerUI(); drawComposite(); }); layersDiv.appendChild(div); }); } function drawComposite() { ctx.clearRect(0,0,canvas.width,canvas.height); state.layers.forEach(layer => ctx.drawImage(layer,0,0)); } document.getElementById('colorPicker').addEventListener('input', e => color = e.target.value); document.getElementById('brushSize').addEventListener('input', e => brushSize = parseInt(e.target.value)); document.getElementById('toolSelect').addEventListener('change', e => tool = e.target.value); document.getElementById('addLayerBtn').addEventListener('click', createLayer); canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('touchstart', startDraw); canvas.addEventListener('mousemove', draw); canvas.addEventListener('touchmove', draw); canvas.addEventListener('mouseup', endDraw); canvas.addEventListener('mouseleave', endDraw); canvas.addEventListener('touchend', endDraw); function getPos(e) { const rect = canvas.getBoundingClientRect(); const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left; const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; return { x: Math.floor(x), y: Math.floor(y) }; } function startDraw(e) { drawing = true; draw(e); } function draw(e) { if (!drawing) return; e.preventDefault(); const pos = getPos(e); const layerCtx = state.layers[state.activeLayer].getContext('2d'); if (tool === 'brush') { layerCtx.fillStyle = color; layerCtx.fillRect(pos.x, pos.y, brushSize, brushSize); } else if (tool === 'eraser') { layerCtx.clearRect(pos.x, pos.y, brushSize, brushSize); } else if (tool === 'fill') { floodFill(layerCtx, pos.x, pos.y, color); } drawComposite(); } function endDraw() { drawing = false; } function floodFill(ctx, x, y, fillColor) { const imgData = ctx.getImageData(0,0,canvas.width,canvas.height); const data = imgData.data; const targetColor = getPixel(data, x, y); const fill = hexToRgb(fillColor); if (colorsMatch(targetColor, fill)) return; const stack = [[x,y]]; while(stack.length) { const [cx,cy] = stack.pop(); const current = getPixel(data, cx, cy); if (colorsMatch(current, targetColor)) { setPixel(data, cx, cy, fill); stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]); } } ctx.putImageData(imgData,0,0); } function getPixel(data, x, y) { const i = (y*canvas.width + x)*4; return [data[i],data[i+1],data[i+2],data[i+3]]; } function setPixel(data, x, y, color) { const i = (y*canvas.width + x)*4; data[i]=color[0]; data[i+1]=color[1]; data[i+2]=color[2]; data[i+3]=255; } function colorsMatch(a,b) { return a[0]===b[0] && a[1]===b[1] && a[2]===b[2]; } function hexToRgb(hex) { const bigint = parseInt(hex.slice(1),16); return [(bigint>>16)&255,(bigint>>8)&255,bigint&255]; } document.getElementById('newBtn').addEventListener('click', () => { state.layers = []; createLayer(); state.currentFile = prompt("Enter new file name:", "pixel_art") || "pixel_art"; }); document.getElementById('saveBtn').addEventListener('click', async () => { drawComposite(); const dataURL = canvas.toDataURL("image/png"); const htmlContent = ` <!DOCTYPE html> <html> <head><meta charset="UTF-8"><title>${state.currentFile}</title></head> <body style="margin:0;background:#2b2b2b;display:flex;justify-content:center;align-items:center;height:100vh;"> <img src="${dataURL}" alt="Pixel Art" style="image-rendering:pixelated;"> </body> </html>`; state.files[state.currentFile] = htmlContent; await saveFile(); }); document.getElementById('exportBtn').addEventListener('click', () => { drawComposite(); const link = document.createElement('a'); link.download = `${state.currentFile}.png`; link.href = canvas.toDataURL("image/png"); link.click(); }); async function saveFile() { const content = state.files[state.currentFile]; let filename = state.currentFile || "untitled"; if (!filename.endsWith(".html")) filename += ".html"; const blob = new Blob([content], { type: "text/html" }); if ('showSaveFilePicker' in window) { try { const handle = await window.showSaveFilePicker({ suggestedName: filename, types: [{ description: "HTML Files", accept: { "text/html": [".html"] } }], }); const writable = await handle.createWritable(); await writable.write(blob); await writable.close(); return; } catch (err) {} } try { const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); return; } catch (err) {} try { const file = new File([blob], filename, { type: "text/html" }); if (navigator.canShare && navigator.canShare({ files: [file] })) { await navigator.share({ files: [file], title: filename }); return; } } catch (err) { alert("Unable to save or share the file on this device."); } } document.getElementById('addFrameBtn').addEventListener('click', () => { const frameData = canvas.toDataURL("image/png"); state.frames.push(frameData); }); document.getElementById('playAnimBtn').addEventListener('click', () => { if (state.playing) { state.playing = false; return; } state.playing = true; let i = 0; const play = () => { if (!state.playing) return; const img = new Image(); img.src = state.frames[i]; img.onload = () => { ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); }; i = (i+1) % state.frames.length; setTimeout(play, 200); }; play(); }); createLayer(); </script> </body> </html>