
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Physics Playground</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #1a103d 0%, #0f172a 100%);
      font-family: 'Inter', system-ui, sans-serif;
    }
    
    canvas {
      display: block;
    }
    
    .control-panel {
      backdrop-filter: blur(8px);
      background-color: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
      max-height: 40vh;
      overflow-y: auto;
    }
    
    input[type="range"] {
      -webkit-appearance: none;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #8b5cf6;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      background: #a78bfa;
    }
    
    button {
      transition: all 0.2s ease;
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    .preset-btn {
      transition: all 0.2s ease;
    }
    
    .preset-btn:active {
      transform: translateY(1px);
    }
    
    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.8; }
    }
    
    .pulse {
      animation: pulse 2s infinite ease-in-out;
    }
    
    /* Mobile optimizations */
    @media (max-width: 640px) {
      .control-panel {
        padding: 0.5rem;
      }
      
      .control-label {
        font-size: 0.7rem;
      }
      
      .btn-sm {
        padding: 0.25rem 0.5rem;
        font-size: 0.7rem;
      }
    }
    
    /* Custom scrollbar for control panel */
    .control-panel::-webkit-scrollbar {
      width: 6px;
    }
    
    .control-panel::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }
    
    .control-panel::-webkit-scrollbar-thumb {
      background: rgba(139, 92, 246, 0.5);
      border-radius: 3px;
    }
    
    .control-panel::-webkit-scrollbar-thumb:hover {
      background: rgba(139, 92, 246, 0.7);
    }
    
    /* Toggle control panel button */
    .toggle-panel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(139, 92, 246, 0.7);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      cursor: pointer;
    }
  </style>
</head>
<body>
<button style="color: tan;" onclick="document.body.requestFullscreen()">FS</button>
  <div class="relative w-full h-screen">
    <canvas id="particleCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
    
    <div class="absolute top-2 left-1/2 transform -translate-x-1/2 text-center z-10">
      <h1 class="text-xl sm:text-2xl font-bold text-white mb-0">Particle Physics Playground</h1>
      <p class="text-purple-300 text-xs">Click or drag to interact with particles</p>
    </div>
    
    <button id="toggleControlPanel" class="toggle-panel">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
        <path d="M12 5v14M5 12h14"></path>
      </svg>
    </button>
    
    <div id="controlPanel" class="control-panel absolute bottom-4 left-1/2 transform -translate-x-1/2 p-2 sm:p-3 rounded-xl text-white w-11/12 max-w-2xl">
      <div class="grid grid-cols-2 gap-2">
        <div>
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Particles: <span id="countValue">150</span></span>
            </label>
            <input type="range" min="10" max="500" value="150" class="w-full" id="particleCount">
          </div>
          
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Gravity: <span id="gravityValue">0.1</span></span>
            </label>
            <input type="range" min="-0.5" max="0.5" step="0.1" value="0" class="w-full" id="gravity">
          </div>
          
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Friction: <span id="frictionValue">0.95</span></span>
            </label>
            <input type="range" min="0.7" max="1" step="0.01" value="0.95" class="w-full" id="friction">
          </div>
        </div>
        
        <div>
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Connections: <span id="connectionValue">150</span>px</span>
            </label>
            <input type="range" min="50" max="300" value="50" class="w-full" id="connectionDistance">
          </div>
          
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Repulsion: <span id="repulsionValue">0.5</span></span>
            </label>
            <input type="range" min="0" max="2" step="0.1" value="0.5" class="w-full" id="repulsion">
          </div>
          
          <div class="mb-2">
            <label class="flex justify-between mb-0 control-label">
              <span>Size: <span id="sizeValue">5</span>px</span>
            </label>
            <input type="range" min="1" max="15" value="5" class="w-full" id="particleSize">
          </div>
        </div>
      </div>
      
      <div class="flex flex-wrap justify-center gap-1 mt-2">
        <button id="resetBtn" class="bg-purple-600 hover:bg-purple-700 px-2 py-1 rounded-lg text-xs sm:text-sm font-medium btn-sm">
          Reset
        </button>
        <button id="explodeBtn" class="bg-pink-600 hover:bg-pink-700 px-2 py-1 rounded-lg text-xs sm:text-sm font-medium btn-sm">
          Explode!
        </button>
        <button id="attractBtn" class="bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded-lg text-xs sm:text-sm font-medium btn-sm">
          Attract
        </button>
        <button id="toggleConnectionsBtn" class="bg-green-600 hover:bg-green-700 px-2 py-1 rounded-lg text-xs sm:text-sm font-medium btn-sm">
          Connections
        </button>
      </div>
      
      <div class="mt-2">
        <p class="text-center text-xs text-purple-300 mb-1">Presets</p>
        <div class="flex flex-wrap justify-center gap-1">
          <button class="preset-btn bg-indigo-900/50 hover:bg-indigo-800 px-2 py-0.5 rounded-lg text-xs" data-preset="galaxy">Galaxy</button>
          <button class="preset-btn bg-indigo-900/50 hover:bg-indigo-800 px-2 py-0.5 rounded-lg text-xs" data-preset="chaos">Chaos</button>
          <button class="preset-btn bg-indigo-900/50 hover:bg-indigo-800 px-2 py-0.5 rounded-lg text-xs" data-preset="fountain">Fountain</button>
          <button class="preset-btn bg-indigo-900/50 hover:bg-indigo-800 px-2 py-0.5 rounded-lg text-xs" data-preset="network">Solo Ball</button>
          <button class="preset-btn bg-indigo-900/50 hover:bg-indigo-800 px-2 py-0.5 rounded-lg text-xs" data-preset="antigravity">Accelerator</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('particleCanvas');
      const ctx = canvas.getContext('2d');
      
      // Mobile detection
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      // Control panel toggle
      const controlPanel = document.getElementById('controlPanel');
      const toggleControlPanel = document.getElementById('toggleControlPanel');
      let isPanelVisible = true;
      
      toggleControlPanel.addEventListener('click', () => {
        isPanelVisible = !isPanelVisible;
        controlPanel.style.display = isPanelVisible ? 'block' : 'none';
        toggleControlPanel.innerHTML = isPanelVisible 
          ? '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="M18 6L6 18M6 6l12 12"></path></svg>'
          : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="M12 5v14M5 12h14"></path></svg>';
      });
      
      // Set canvas to full window size
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.scale(dpr, dpr);
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // Controls
      const countSlider = document.getElementById('particleCount');
      const countValue = document.getElementById('countValue');
      const gravitySlider = document.getElementById('gravity');
      const gravityValue = document.getElementById('gravityValue');
      const frictionSlider = document.getElementById('friction');
      const frictionValue = document.getElementById('frictionValue');
      const connectionSlider = document.getElementById('connectionDistance');
      const connectionValue = document.getElementById('connectionValue');
      const repulsionSlider = document.getElementById('repulsion');
      const repulsionValue = document.getElementById('repulsionValue');
      const sizeSlider = document.getElementById('particleSize');
      const sizeValue = document.getElementById('sizeValue');
      
      // Buttons
      const resetBtn = document.getElementById('resetBtn');
      const explodeBtn = document.getElementById('explodeBtn');
      const attractBtn = document.getElementById('attractBtn');
      const toggleConnectionsBtn = document.getElementById('toggleConnectionsBtn');
      const presetBtns = document.querySelectorAll('.preset-btn');
      
      // Simulation parameters
      let config = {
        particleCount: parseInt(countSlider.value),
        gravity: parseFloat(gravitySlider.value),
        friction: parseFloat(frictionSlider.value),
        connectionDistance: parseInt(connectionSlider.value),
        repulsion: parseFloat(repulsionSlider.value),
        particleSize: parseInt(sizeSlider.value),
        showConnections: true,
        mouseInteraction: true,
        mouseRadius: isMobile ? 100 : 150,
        mouseForce: 1
      };
      
      // Particles array
      let particles = [];
      
      // Mouse/touch position
      let pointer = {
        x: null,
        y: null,
        radius: config.mouseRadius,
        isPressed: false,
        lastUpdate: 0
      };
      
      // Color palette
      const colors = [
        '#8b5cf6', // Purple
        '#ec4899', // Pink
        '#3b82f6', // Blue
        '#10b981', // Green
        '#f59e0b', // Amber
      ];
      
      // Particle class
      class Particle {
        constructor(x, y, size) {
          this.x = x;
          this.y = y;
          this.size = size;
          this.baseSize = size;
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = (Math.random() - 0.5) * 2;
          this.mass = this.size / 2;
        }
        
        update() {
          // Apply gravity
          this.vy += config.gravity;
          
          // Apply friction
          this.vx *= config.friction;
          this.vy *= config.friction;
          
          // Update position
          this.x += this.vx;
          this.y += this.vy;
          
          // Bounce off walls
          if (this.x < this.size) {
            this.x = this.size;
            this.vx *= -0.8;
          }
          if (this.x > window.innerWidth - this.size) {
            this.x = window.innerWidth - this.size;
            this.vx *= -0.8;
          }
          if (this.y < this.size) {
            this.y = this.size;
            this.vy *= -0.8;
          }
          if (this.y > window.innerHeight - this.size) {
            this.y = window.innerHeight - this.size;
            this.vy *= -0.8;
          }
          
          // Mouse/touch interaction
          if (config.mouseInteraction && pointer.x !== null && pointer.y !== null) {
            const dx = this.x - pointer.x;
            const dy = this.y - pointer.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < pointer.radius) {
              if (pointer.isPressed) {
                // Attract to pointer when pressed
                const force = pointer.radius / distance * config.mouseForce * 0.02;
                this.vx -= dx * force;
                this.vy -= dy * force;
                this.size = this.baseSize * 1.5; // Grow when attracted
              } else {
                // Repel from pointer when not pressed
                const force = pointer.radius / distance * config.repulsion * 0.1;
                this.vx += dx * force;
                this.vy += dy * force;
              }
            } else {
              // Return to original size
              if (this.size > this.baseSize) {
                this.size -= 0.1;
              }
              if (this.size < this.baseSize) {
                this.size += 0.1;
              }
            }
          }
        }
        
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          
          // Add glow effect
          ctx.shadowBlur = 15;
          ctx.shadowColor = this.color;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      // Create particles
      function createParticles() {
        particles = [];
        for (let i = 0; i < config.particleCount; i++) {
          const size = Math.random() * config.particleSize + 2;
          const x = Math.random() * (window.innerWidth - size * 2) + size;
          const y = Math.random() * (window.innerHeight - size * 2) + size;
          particles.push(new Particle(x, y, size));
        }
      }
      
      // Draw connections between particles
      function drawConnections() {
        if (!config.showConnections) return;
        
        ctx.lineWidth = 0.5;
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < config.connectionDistance) {
              const opacity = 1 - (distance / config.connectionDistance);
              ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
              ctx.beginPath();
              ctx.moveTo(particles[i].x, particles[i].y);
              ctx.lineTo(particles[j].x, particles[j].y);
              ctx.stroke();
            }
          }
        }
      }
      
      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
        
        drawConnections();
        
        particles.forEach(particle => {
          particle.update();
          particle.draw();
        });
        
        requestAnimationFrame(animate);
      }
      
      // Initialize
      createParticles();
      animate();
      
      // Event listeners for controls
      countSlider.addEventListener('input', () => {
        config.particleCount = parseInt(countSlider.value);
        countValue.textContent = countSlider.value;
        createParticles();
      });
      
      gravitySlider.addEventListener('input', () => {
        config.gravity = parseFloat(gravitySlider.value);
        gravityValue.textContent = gravitySlider.value;
      });
      
      frictionSlider.addEventListener('input', () => {
        config.friction = parseFloat(frictionSlider.value);
        frictionValue.textContent = frictionSlider.value;
      });
      
      connectionSlider.addEventListener('input', () => {
        config.connectionDistance = parseInt(connectionSlider.value);
        connectionValue.textContent = connectionSlider.value;
      });
      
      repulsionSlider.addEventListener('input', () => {
        config.repulsion = parseFloat(repulsionSlider.value);
        repulsionValue.textContent = repulsionSlider.value;
      });
      
      sizeSlider.addEventListener('input', () => {
        config.particleSize = parseInt(sizeSlider.value);
        sizeValue.textContent = sizeSlider.value;
        particles.forEach(p => {
          p.baseSize = Math.random() * config.particleSize + 2;
          p.size = p.baseSize;
        });
      });
      
      // Button actions
      resetBtn.addEventListener('click', () => {
        createParticles();
      });
      
      explodeBtn.addEventListener('click', () => {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        particles.forEach(p => {
          const dx = p.x - centerX;
          const dy = p.y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const force = 15;
          p.vx += Math.cos(angle) * force;
          p.vy += Math.sin(angle) * force;
        });
      });
      
      attractBtn.addEventListener('click', () => {
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        particles.forEach(p => {
          const dx = p.x - centerX;
          const dy = p.y - centerY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
          
          const force = 5;
          p.vx -= Math.cos(angle) * force;
          p.vy -= Math.sin(angle) * force;
        });
      });
      
      toggleConnectionsBtn.addEventListener('click', () => {
        config.showConnections = !config.showConnections;
        toggleConnectionsBtn.textContent = config.showConnections ? 'Hide Connections' : 'Show Connections';
      });
      
      // Presets
      presetBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const preset = btn.dataset.preset;
          
          switch(preset) {
            case 'galaxy':
              config.gravity = 0.0;
              config.friction = 1;
              config.connectionDistance = 50;
              config.repulsion = 0;
              config.particleSize = 3;
              config.showConnections = true;
              
              // Update sliders
              gravitySlider.value = config.gravity;
              gravityValue.textContent = config.gravity;
              frictionSlider.value = config.friction;
              frictionValue.textContent = config.friction;
              connectionSlider.value = config.connectionDistance;
              connectionValue.textContent = config.connectionDistance;
              repulsionSlider.value = config.repulsion;
              repulsionValue.textContent = config.repulsion;
              sizeSlider.value = config.particleSize;
              sizeValue.textContent = config.particleSize;
              
              // Create spiral galaxy
              particles = [];
              const centerX = window.innerWidth / 2;
              const centerY = window.innerHeight / 2;
              
              for (let i = 0; i < config.particleCount; i++) {
                const size = Math.random() * config.particleSize + 1;
                const radius = Math.random() * 200 + 20;
                const angle = Math.random() * Math.PI * 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                const p = new Particle(x, y, size);
                const orbitSpeed = 2 / Math.sqrt(radius);
                p.vx = -Math.sin(angle) * orbitSpeed;
                p.vy = Math.cos(angle) * orbitSpeed;
                particles.push(p);
              }
              break;
              
            case 'chaos':
              config.gravity = 0.05;
              config.friction = 1;
              config.connectionDistance = 200;
              config.repulsion = 2;
              config.particleSize = 6;
              config.showConnections = false;
              
              // Update sliders
              gravitySlider.value = config.gravity;
              gravityValue.textContent = config.gravity;
              frictionSlider.value = config.friction;
              frictionValue.textContent = config.friction;
              connectionSlider.value = config.connectionDistance;
              connectionValue.textContent = config.connectionDistance;
              repulsionSlider.value = config.repulsion;
              repulsionValue.textContent = config.repulsion;
              sizeSlider.value = config.particleSize;
              sizeValue.textContent = config.particleSize;
              
              createParticles();
              particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * 10;
                p.vy = (Math.random() - 0.5) * 10;
              });
              break;
              
            case 'fountain':
              config.gravity = 0.05;
              config.friction = 0.99;
              config.connectionDistance = 100;
              config.repulsion = 0.0;
              config.particleSize = 4;
              config.showConnections = false;
              
              // Update sliders
              gravitySlider.value = config.gravity;
              gravityValue.textContent = config.gravity;
              frictionSlider.value = config.friction;
              frictionValue.textContent = config.friction;
              connectionSlider.value = config.connectionDistance;
              connectionValue.textContent = config.connectionDistance;
              repulsionSlider.value = config.repulsion;
              repulsionValue.textContent = config.repulsion;
              sizeSlider.value = config.particleSize;
              sizeValue.textContent = config.particleSize;
              
              particles = [];
              for (let i = 0; i < config.particleCount; i++) {
                const size = Math.random() * config.particleSize + 2;
                const x = window.innerWidth / 2 + (Math.random() - 0.5) * 50;
                const y = window.innerHeight - 50;
                
                const p = new Particle(x, y, size);
                p.vx = (Math.random() - 0.5) * 3;
                p.vy = -Math.random() * 10 - 5;
                particles.push(p);
              }
              break;
              
            case 'network':
              config.particleCount = 1;
              config.gravity = 0.0;
              config.connectionDistance = 100;
              config.repulsion = 0;
              config.particleSize = 3;
              config.showConnections = true;
              
              // Update sliders
              countSlider.value = config.particleCount;
              countValue.textContent = config.particleCount;
              gravitySlider.value = config.gravity;
              gravityValue.textContent = config.gravity;
              frictionSlider.value = config.friction;
              frictionValue.textContent = config.friction;
              connectionSlider.value = config.connectionDistance;
              connectionValue.textContent = config.connectionDistance;
              repulsionSlider.value = config.repulsion;
              repulsionValue.textContent = config.repulsion;
              sizeSlider.value = config.particleSize;
              sizeValue.textContent = config.particleSize;
              
              createParticles();
              particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * 1;
                p.vy = (Math.random() - 0.5) * 1;
              });
              break;
              
            case 'antigravity':
              config.gravity = 0.0;
              config.friction = 0;
              config.connectionDistance = 5;
              config.repulsion = 0;
              config.particleSize = 5;
              config.showConnections = false;
              
              // Update sliders
              gravitySlider.value = config.gravity;
              gravityValue.textContent = config.gravity;
              connectionSlider.value = config.connectionDistance;
              connectionValue.textContent = config.connectionDistance;
              repulsionSlider.value = config.repulsion;
              repulsionValue.textContent = config.repulsion;
              sizeSlider.value = config.particleSize;
              sizeValue.textContent = config.particleSize;
              
              createParticles();
              config.friction = 1.005; 
              frictionSlider.value = config.friction;
              frictionValue.textContent = config.friction; 
              break;
          }
          
          // Update toggle connections button text
          toggleConnectionsBtn.textContent = config.showConnections ? 'Hide Connections' : 'Show Connections';
        });
      });
      
      // Mouse events
      canvas.addEventListener('mousemove', (e) => {
        pointer.x = e.x;
        pointer.y = e.y;
      });
      
      canvas.addEventListener('mousedown', () => {
        pointer.isPressed = true;
      });
      
      canvas.addEventListener('mouseup', () => {
        pointer.isPressed = false;
      });
      
      canvas.addEventListener('mouseleave', () => {
        pointer.x = null;
        pointer.y = null;
        pointer.isPressed = false;
      });
      
      // Touch events for mobile
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        pointer.isPressed = true;
        pointer.x = e.touches[0].clientX;
        pointer.y = e.touches[0].clientY;
      }, { passive: false });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        pointer.x = e.touches[0].clientX;
        pointer.y = e.touches[0].clientY;
      }, { passive: false });
      
      canvas.addEventListener('touchend', () => {
        pointer.isPressed = false;
      });
    });
  </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'95548a25618745f5',t:'MTc1MDg1NTI5MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>


