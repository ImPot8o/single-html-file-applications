
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Rush - Infinite Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            font-weight: bold;
        }

        .game-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: 2px;
            width: 300px;
            height: 300px;
            background: #2c3e50;
            border-radius: 10px;
            padding: 10px;
            position: relative;
        }

        .cell {
            background: #34495e;
            border-radius: 4px;
            position: relative;
        }

        .block {
            position: absolute;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            user-select: none;
            touch-action: none;
        }

        .block:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .block.dragging {
            z-index: 1000;
            transform: scale(1.1);
        }

        .target-block {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            border: 3px solid #fff;
        }

        .exit {
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.success {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .success-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            padding: 30px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .success-message.show {
            opacity: 1;
        }

        @media (max-width: 480px) {
            .grid {
                width: 280px;
                height: 280px;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .stats {
                gap: 10px;
            }
            
            .stat {
                padding: 8px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
<button onclick="document.body.requestFullscreen()">Full Screen</button>
    <div class="header">
        <h1 class="title">üöó Block Rush</h1>
        <div class="stats">
            <div class="stat">Level: <span id="level">1</span></div>
            <div class="stat">Moves: <span id="moves">0</span></div>
            <div class="stat">Best: <span id="best">-</span></div>
        </div>
    </div>

    <div class="game-container">
        <div class="grid" id="grid">
            <div class="exit">üèÅ</div>
        </div>
    </div>

    <div class="controls">
        <button class="btn" onclick="resetLevel()">üîÑ Reset</button>
        <button class="btn" onclick="newLevel()">‚è≠Ô∏è Skip</button>
        <button class="btn" onclick="showHint()">üí° Hint</button>
    </div>

    <div class="success-message" id="successMessage">
        üéâ Level Complete! üéâ<br>
        <small>Generating next puzzle...</small>
    </div>

    <script>
        class BlockRushGame {
            constructor() {
                this.grid = document.getElementById('grid');
                this.level = 1;
                this.moves = 0;
                this.bestScore = localStorage.getItem('blockRushBest') || null;
                this.blocks = [];
                this.gridSize = 6;
                this.cellSize = 45;
                this.isDragging = false;
                this.dragBlock = null;
                this.startPos = { x: 0, y: 0 };
                
                this.updateDisplay();
                this.generateLevel();
                this.setupEventListeners();
            }

            generateLevel() {
                this.blocks = [];
                this.grid.innerHTML = '<div class="exit">üèÅ</div>';
                
                // Create target block (red car that needs to exit)
                const targetBlock = {
                    id: 'target',
                    x: 0,
                    y: 2,
                    width: 2,
                    height: 1,
                    color: 'linear-gradient(45deg, #e74c3c, #c0392b)',
                    isTarget: true,
                    direction: 'horizontal'
                };
                this.blocks.push(targetBlock);

                // Generate random blocking pieces
                const colors = [
                    'linear-gradient(45deg, #9b59b6, #8e44ad)',
                    'linear-gradient(45deg, #f39c12, #e67e22)',
                    'linear-gradient(45deg, #1abc9c, #16a085)',
                    'linear-gradient(45deg, #34495e, #2c3e50)',
                    'linear-gradient(45deg, #e67e22, #d35400)',
                    'linear-gradient(45deg, #95a5a6, #7f8c8d)'
                ];

                // Add vertical blocks
                for (let i = 0; i < 3 + Math.floor(this.level / 3); i++) {
                    let attempts = 0;
                    while (attempts < 50) {
                        const x = Math.floor(Math.random() * 6);
                        const y = Math.floor(Math.random() * 4);
                        const height = Math.random() > 0.5 ? 3 : 2;
                        
                        if (this.canPlaceBlock(x, y, 1, height)) {
                            this.blocks.push({
                                id: `block${i}v`,
                                x, y,
                                width: 1,
                                height,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                direction: 'vertical'
                            });
                            break;
                        }
                        attempts++;
                    }
                }

                // Add horizontal blocks
                for (let i = 0; i < 2 + Math.floor(this.level / 4); i++) {
                    let attempts = 0;
                    while (attempts < 50) {
                        const x = Math.floor(Math.random() * 4);
                        const y = Math.floor(Math.random() * 6);
                        const width = Math.random() > 0.5 ? 3 : 2;
                        
                        if (y !== 2 && this.canPlaceBlock(x, y, width, 1)) {
                            this.blocks.push({
                                id: `block${i}h`,
                                x, y,
                                width,
                                height: 1,
                                color: colors[Math.floor(Math.random() * colors.length)],
                                direction: 'horizontal'
                            });
                            break;
                        }
                        attempts++;
                    }
                }

                this.renderBlocks();
                this.moves = 0;
                this.updateDisplay();
            }

            canPlaceBlock(x, y, width, height) {
                if (x + width > this.gridSize || y + height > this.gridSize) return false;
                
                for (let block of this.blocks) {
                    if (this.blocksOverlap(x, y, width, height, block.x, block.y, block.width, block.height)) {
                        return false;
                    }
                }
                return true;
            }

            blocksOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
                return !(x1 >= x2 + w2 || x2 >= x1 + w1 || y1 >= y2 + h2 || y2 >= y1 + h1);
            }

            renderBlocks() {
                this.blocks.forEach(block => {
                    const blockEl = document.createElement('div');
                    blockEl.className = 'block' + (block.isTarget ? ' target-block' : '');
                    blockEl.id = block.id;
                    blockEl.style.left = `${block.x * (this.cellSize + 2) + 10}px`;
                    blockEl.style.top = `${block.y * (this.cellSize + 2) + 10}px`;
                    blockEl.style.width = `${block.width * this.cellSize + (block.width - 1) * 2}px`;
                    blockEl.style.height = `${block.height * this.cellSize + (block.height - 1) * 2}px`;
                    blockEl.style.background = block.color;
                    
                    if (block.isTarget) {
                        blockEl.innerHTML = 'üöó';
                    } else {
                        blockEl.innerHTML = block.direction === 'vertical' ? 'üì¶' : 'üì¶';
                    }
                    
                    this.grid.appendChild(blockEl);
                });
            }

            setupEventListeners() {
                this.grid.addEventListener('mousedown', this.handleStart.bind(this));
                this.grid.addEventListener('touchstart', this.handleStart.bind(this), { passive: false });
                
                document.addEventListener('mousemove', this.handleMove.bind(this));
                document.addEventListener('touchmove', this.handleMove.bind(this), { passive: false });
                
                document.addEventListener('mouseup', this.handleEnd.bind(this));
                document.addEventListener('touchend', this.handleEnd.bind(this));
            }

            handleStart(e) {
                e.preventDefault();
                const target = e.target.closest('.block');
                if (!target) return;

                this.isDragging = true;
                this.dragBlock = this.blocks.find(b => b.id === target.id);
                
                const rect = this.grid.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                this.startPos = {
                    x: clientX - rect.left,
                    y: clientY - rect.top,
                    blockX: this.dragBlock.x,
                    blockY: this.dragBlock.y
                };
                
                target.classList.add('dragging');
            }

            handleMove(e) {
                if (!this.isDragging || !this.dragBlock) return;
                e.preventDefault();

                const rect = this.grid.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const currentX = clientX - rect.left;
                const currentY = clientY - rect.top;
                
                const deltaX = currentX - this.startPos.x;
                const deltaY = currentY - this.startPos.y;
                
                let newX = this.startPos.blockX;
                let newY = this.startPos.blockY;
                
                if (this.dragBlock.direction === 'horizontal') {
                    const gridDeltaX = Math.round(deltaX / (this.cellSize + 2));
                    newX = Math.max(0, Math.min(this.gridSize - this.dragBlock.width, this.startPos.blockX + gridDeltaX));
                } else {
                    const gridDeltaY = Math.round(deltaY / (this.cellSize + 2));
                    newY = Math.max(0, Math.min(this.gridSize - this.dragBlock.height, this.startPos.blockY + gridDeltaY));
                }
                
                if (this.canMoveBlock(this.dragBlock, newX, newY)) {
                    const blockEl = document.getElementById(this.dragBlock.id);
                    blockEl.style.left = `${newX * (this.cellSize + 2) + 10}px`;
                    blockEl.style.top = `${newY * (this.cellSize + 2) + 10}px`;
                }
            }

            handleEnd(e) {
                if (!this.isDragging || !this.dragBlock) return;

                const blockEl = document.getElementById(this.dragBlock.id);
                blockEl.classList.remove('dragging');
                
                const rect = this.grid.getBoundingClientRect();
                const clientX = e.clientX || e.changedTouches[0].clientX;
                const clientY = e.clientY || e.changedTouches[0].clientY;
                
                const currentX = clientX - rect.left;
                const currentY = clientY - rect.top;
                
                const deltaX = currentX - this.startPos.x;
                const deltaY = currentY - this.startPos.y;
                
                let newX = this.startPos.blockX;
                let newY = this.startPos.blockY;
                
                if (this.dragBlock.direction === 'horizontal') {
                    const gridDeltaX = Math.round(deltaX / (this.cellSize + 2));
                    newX = Math.max(0, Math.min(this.gridSize - this.dragBlock.width, this.startPos.blockX + gridDeltaX));
                } else {
                    const gridDeltaY = Math.round(deltaY / (this.cellSize + 2));
                    newY = Math.max(0, Math.min(this.gridSize - this.dragBlock.height, this.startPos.blockY + gridDeltaY));
                }
                
                if (this.canMoveBlock(this.dragBlock, newX, newY)) {
                    if (newX !== this.dragBlock.x || newY !== this.dragBlock.y) {
                        this.dragBlock.x = newX;
                        this.dragBlock.y = newY;
                        this.moves++;
                        this.updateDisplay();
                        this.checkWin();
                    }
                }
                
                // Snap to grid
                blockEl.style.left = `${this.dragBlock.x * (this.cellSize + 2) + 10}px`;
                blockEl.style.top = `${this.dragBlock.y * (this.cellSize + 2) + 10}px`;
                
                this.isDragging = false;
                this.dragBlock = null;
            }

            canMoveBlock(block, newX, newY) {
                for (let otherBlock of this.blocks) {
                    if (otherBlock.id === block.id) continue;
                    if (this.blocksOverlap(newX, newY, block.width, block.height, 
                                         otherBlock.x, otherBlock.y, otherBlock.width, otherBlock.height)) {
                        return false;
                    }
                }
                return true;
            }

            checkWin() {
                const targetBlock = this.blocks.find(b => b.isTarget);
                if (targetBlock && targetBlock.x + targetBlock.width >= this.gridSize) {
                    this.showSuccess();
                    
                    if (!this.bestScore || this.moves < this.bestScore) {
                        this.bestScore = this.moves;
                        localStorage.setItem('blockRushBest', this.bestScore);
                    }
                    
                    setTimeout(() => {
                        this.level++;
                        this.generateLevel();
                        this.hideSuccess();
                    }, 2000);
                }
            }

            showSuccess() {
                const msg = document.getElementById('successMessage');
                msg.classList.add('show');
            }

            hideSuccess() {
                const msg = document.getElementById('successMessage');
                msg.classList.remove('show');
            }

            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('moves').textContent = this.moves;
                document.getElementById('best').textContent = this.bestScore || '-';
            }

            resetLevel() {
                this.generateLevel();
            }

            newLevel() {
                this.level++;
                this.generateLevel();
            }

            showHint() {
                const targetBlock = this.blocks.find(b => b.isTarget);
                const blockEl = document.getElementById(targetBlock.id);
                blockEl.style.animation = 'pulse 1s ease-in-out 3';
                
                setTimeout(() => {
                    blockEl.style.animation = '';
                }, 3000);
            }
        }

        // Initialize game
        let game;
        window.addEventListener('load', () => {
            game = new BlockRushGame();
        });

        // Global functions for buttons
        function resetLevel() {
            game.resetLevel();
        }

        function newLevel() {
            game.newLevel();
        }

        function showHint() {
            game.showHint();
        }

        // Add pulse animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
        `;
        document.head.appendChild(style);
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'95611cba13cc6160',t:'MTc1MDk4NzEyNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
