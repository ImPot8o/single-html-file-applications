
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Protocol</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .game-ui {
            position: absolute;
            z-index: 2;
            pointer-events: none;
        }
        .control-area {
            pointer-events: auto;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }
        .health-bar {
            height: 10px;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            border-radius: 5px;
            transition: width 0.3s;
        }
        .ammo-count {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .mission-text {
            background-color: rgba(0,0,0,0.7);
            border-left: 4px solid #ffcc00;
            animation: fadeIn 1s ease-in-out;
        }
        .button {
            background: linear-gradient(to bottom, #3d3d3d, #1a1a1a);
            border: 2px solid #ffcc00;
            color: #ffcc00;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            pointer-events: auto;
            user-select: none;
        }
        .joystick-base {
            width: 120px;
            height: 120px;
            background-color: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
        }
        .joystick-thumb {
            width: 50px;
            height: 50px;
            background: linear-gradient(to bottom, #ffcc00, #cc9900);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .menu {
            background-color: rgba(0,0,0,0.85);
            border: 2px solid #ffcc00;
        }
        .menu-button {
            background: linear-gradient(to bottom, #3d3d3d, #1a1a1a);
            border: 2px solid #ffcc00;
            color: #ffcc00;
            transition: all 0.2s;
        }
        .menu-button:active {
            background: linear-gradient(to bottom, #ffcc00, #cc9900);
            color: #000;
        }
        .level-card {
            background-color: rgba(0,0,0,0.7);
            border: 1px solid #ffcc00;
            transition: all 0.2s;
        }
        .level-card.locked {
            filter: grayscale(1);
            opacity: 0.7;
        }
        .level-card:not(.locked):active {
            transform: scale(0.98);
            background-color: rgba(40,40,40,0.7);
        }
        .objective-item {
            border-left: 3px solid #ffcc00;
        }
        .objective-item.completed {
            border-left: 3px solid #00cc00;
            color: #00cc00;
        }
        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            border: 0px solid rgba(255,0,0,0.3);
            box-sizing: border-box;
            opacity: 0;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-black">
    <div id="gameCanvas"></div>
    <div id="damageOverlay" class="damage-overlay"></div>
    
    <!-- Game UI -->
    <div id="gameUI" class="game-ui w-full h-full hidden">
        <!-- Crosshair -->
        <svg class="crosshair" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="48" stroke="#ffcc00" stroke-width="2" fill="none" />
            <line x1="50" y1="25" x2="50" y2="75" stroke="#ffcc00" stroke-width="2" />
            <line x1="25" y1="50" x2="75" y2="50" stroke="#ffcc00" stroke-width="2" />
        </svg>
        
        <!-- Health and Ammo -->
        <div class="absolute top-4 left-4 right-4 flex justify-between items-center">
            <div class="bg-black bg-opacity-50 p-2 rounded-lg flex items-center">
                <div class="text-red-500 mr-2">HP</div>
                <div class="w-32 bg-gray-800 rounded-full overflow-hidden">
                    <div id="healthBar" class="health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="bg-black bg-opacity-50 p-2 rounded-lg">
                <span class="text-white ammo-count"><span id="currentAmmo">30</span>/<span id="maxAmmo">30</span></span>
            </div>
        </div>
        
        <!-- Mission Info -->
        <div id="missionInfo" class="absolute top-16 left-4 right-4 mission-text text-white p-3 rounded hidden">
            <h3 class="text-yellow-400 font-bold">New Objective</h3>
            <p id="missionText">Infiltrate the facility and locate the server room.</p>
        </div>
        
        <!-- Controls -->
        <div class="absolute bottom-4 left-4 control-area">
            <div id="joystick" class="joystick-base">
                <div id="joystickThumb" class="joystick-thumb"></div>
            </div>
        </div>
        
        <div class="absolute bottom-4 right-4 flex gap-4 control-area">
            <div id="jumpButton" class="button">JUMP</div>
            <div id="shootButton" class="button">FIRE</div>
        </div>
        
        <!-- Objectives Panel -->
        <div id="objectivesPanel" class="absolute top-4 right-4 bg-black bg-opacity-70 p-3 rounded-lg border-l-4 border-yellow-500 hidden">
            <h3 class="text-yellow-400 font-bold mb-2">Objectives</h3>
            <ul id="objectivesList" class="space-y-2">
                <!-- Objectives will be added here -->
            </ul>
        </div>
    </div>
    
    <!-- Main Menu -->
    <div id="mainMenu" class="absolute inset-0 flex flex-col items-center justify-center menu z-10">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-yellow-400 mb-2">SHADOW PROTOCOL</h1>
            <p class="text-gray-300">A covert mission awaits</p>
        </div>
        
        <div class="flex flex-col gap-4 w-64">
            <button id="playButton" class="menu-button py-3 px-6 rounded-lg text-lg font-bold">PLAY MISSION</button>
            <button id="levelSelectButton" class="menu-button py-3 px-6 rounded-lg text-lg font-bold">SELECT LEVEL</button>
            <button id="controlsButton" class="menu-button py-3 px-6 rounded-lg text-lg font-bold">CONTROLS</button>
        </div>
    </div>
    
    <!-- Level Select Screen -->
    <div id="levelSelect" class="absolute inset-0 menu z-10 p-4 flex flex-col hidden">
        <h2 class="text-2xl font-bold text-yellow-400 mb-4">SELECT MISSION</h2>
        
        <div class="flex-1 overflow-y-auto grid grid-cols-1 md:grid-cols-2 gap-4 pb-16">
            <div class="level-card p-4 rounded-lg" data-level="1">
                <h3 class="text-yellow-400 font-bold">01: Infiltration</h3>
                <p class="text-gray-300 text-sm">Enter the enemy compound and establish a foothold.</p>
                <div class="mt-2 flex justify-between items-center">
                    <span class="text-xs text-gray-400">Difficulty: Easy</span>
                    <div class="flex">
                        <span class="text-yellow-400">★</span>
                        <span class="text-yellow-400">★</span>
                        <span class="text-gray-600">★</span>
                    </div>
                </div>
            </div>
            
            <div class="level-card p-4 rounded-lg" data-level="2">
                <h3 class="text-yellow-400 font-bold">02: Server Room</h3>
                <p class="text-gray-300 text-sm">Hack into the mainframe and extract classified data.</p>
                <div class="mt-2 flex justify-between items-center">
                    <span class="text-xs text-gray-400">Difficulty: Medium</span>
                    <div class="flex">
                        <span class="text-yellow-400">★</span>
                        <span class="text-yellow-400">★</span>
                        <span class="text-yellow-400">★</span>
                    </div>
                </div>
            </div>
            
            <div class="level-card p-4 rounded-lg locked" data-level="3">
                <h3 class="text-gray-400 font-bold">03: Escape</h3>
                <p class="text-gray-500 text-sm">Fight your way out as alarms blare throughout the facility.</p>
                <div class="mt-2 flex justify-between items-center">
                    <span class="text-xs text-gray-500">Difficulty: Hard</span>
                    <div class="flex">
                        <span class="text-gray-600">★</span>
                        <span class="text-gray-600">★</span>
                        <span class="text-gray-600">★</span>
                    </div>
                </div>
                <div class="absolute inset-0 flex items-center justify-center">
                    <div class="bg-black bg-opacity-70 p-2 rounded">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                        </svg>
                    </div>
                </div>
            </div>
        </div>
        
        <button id="backFromLevels" class="menu-button py-3 px-6 rounded-lg text-lg font-bold self-center mt-4">BACK</button>
    </div>
    
    <!-- Controls Screen -->
    <div id="controlsScreen" class="absolute inset-0 menu z-10 p-4 flex flex-col hidden">
        <h2 class="text-2xl font-bold text-yellow-400 mb-4">CONTROLS</h2>
        
        <div class="flex-1 overflow-y-auto">
            <div class="bg-gray-900 bg-opacity-50 p-4 rounded-lg mb-4">
                <h3 class="text-yellow-400 font-bold mb-2">Movement</h3>
                <p class="text-gray-300">Use the left joystick to move your agent.</p>
                <div class="mt-4 flex items-center justify-center">
                    <div class="w-20 h-20 bg-black bg-opacity-50 rounded-full relative">
                        <div class="absolute w-8 h-8 bg-yellow-500 rounded-full top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"></div>
                    </div>
                </div>
            </div>
            
            <div class="bg-gray-900 bg-opacity-50 p-4 rounded-lg mb-4">
                <h3 class="text-yellow-400 font-bold mb-2">Look/Aim</h3>
                <p class="text-gray-300">Swipe anywhere on the screen to look around and aim.</p>
                <div class="mt-4 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" />
                    </svg>
                </div>
            </div>
            
            <div class="bg-gray-900 bg-opacity-50 p-4 rounded-lg mb-4">
                <h3 class="text-yellow-400 font-bold mb-2">Actions</h3>
                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center">
                        <div class="w-12 h-12 bg-gray-800 rounded-full flex items-center justify-center mx-auto mb-2 border-2 border-yellow-500">
                            <span class="text-yellow-500 font-bold">FIRE</span>
                        </div>
                        <p class="text-gray-300 text-sm">Shoot weapon</p>
                    </div>
                    <div class="text-center">
                        <div class="w-12 h-12 bg-gray-800 rounded-full flex items-center justify-center mx-auto mb-2 border-2 border-yellow-500">
                            <span class="text-yellow-500 font-bold">JUMP</span>
                        </div>
                        <p class="text-gray-300 text-sm">Jump/Interact</p>
                    </div>
                </div>
            </div>
        </div>
        
        <button id="backFromControls" class="menu-button py-3 px-6 rounded-lg text-lg font-bold self-center mt-4">BACK</button>
    </div>
    
    <!-- Pause Menu -->
    <div id="pauseMenu" class="absolute inset-0 flex items-center justify-center menu z-20 hidden">
        <div class="bg-black bg-opacity-90 p-6 rounded-lg border-2 border-yellow-500 w-64">
            <h2 class="text-2xl font-bold text-yellow-400 mb-4 text-center">PAUSED</h2>
            
            <div class="flex flex-col gap-3">
                <button id="resumeButton" class="menu-button py-2 px-4 rounded-lg font-bold">RESUME</button>
                <button id="restartButton" class="menu-button py-2 px-4 rounded-lg font-bold">RESTART</button>
                <button id="exitToMenuButton" class="menu-button py-2 px-4 rounded-lg font-bold">EXIT TO MENU</button>
            </div>
        </div>
    </div>
    
    <!-- Mission Complete Screen -->
    <div id="missionComplete" class="absolute inset-0 flex items-center justify-center menu z-20 hidden">
        <div class="bg-black bg-opacity-90 p-6 rounded-lg border-2 border-yellow-500 w-80">
            <h2 class="text-2xl font-bold text-yellow-400 mb-2 text-center">MISSION COMPLETE</h2>
            
            <div class="my-4 text-center">
                <div class="flex justify-center mb-2">
                    <span class="text-yellow-400 text-2xl">★</span>
                    <span class="text-yellow-400 text-2xl">★</span>
                    <span id="thirdStar" class="text-gray-600 text-2xl">★</span>
                </div>
                <p class="text-gray-300" id="missionCompleteText">You've successfully completed the mission!</p>
            </div>
            
            <div class="bg-gray-900 bg-opacity-50 p-3 rounded-lg mb-4">
                <div class="flex justify-between mb-1">
                    <span class="text-gray-300">Time:</span>
                    <span class="text-white" id="missionTime">03:24</span>
                </div>
                <div class="flex justify-between mb-1">
                    <span class="text-gray-300">Accuracy:</span>
                    <span class="text-white" id="missionAccuracy">68%</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-300">Enemies defeated:</span>
                    <span class="text-white" id="enemiesDefeated">12/15</span>
                </div>
            </div>
            
            <div class="flex flex-col gap-3">
                <button id="nextMissionButton" class="menu-button py-2 px-4 rounded-lg font-bold">NEXT MISSION</button>
                <button id="replayMissionButton" class="menu-button py-2 px-4 rounded-lg font-bold">REPLAY</button>
                <button id="exitToMenuFromComplete" class="menu-button py-2 px-4 rounded-lg font-bold">EXIT TO MENU</button>
            </div>
        </div>
    </div>
    
    <!-- Mission Failed Screen -->
    <div id="missionFailed" class="absolute inset-0 flex items-center justify-center menu z-20 hidden">
        <div class="bg-black bg-opacity-90 p-6 rounded-lg border-2 border-red-700 w-64">
            <h2 class="text-2xl font-bold text-red-500 mb-4 text-center">MISSION FAILED</h2>
            
            <p class="text-gray-300 text-center mb-4" id="failureReason">Agent down. Mission compromised.</p>
            
            <div class="flex flex-col gap-3">
                <button id="retryMissionButton" class="menu-button py-2 px-4 rounded-lg font-bold">RETRY</button>
                <button id="exitToMenuFromFailed" class="menu-button py-2 px-4 rounded-lg font-bold">EXIT TO MENU</button>
            </div>
        </div>
    </div>
    
    <!-- Pause Button (in-game) -->
    <div id="pauseButton" class="absolute top-4 right-4 w-10 h-10 bg-black bg-opacity-50 rounded-full flex items-center justify-center z-10 hidden">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
    </div>

    <script>
        // Game state
        const gameState = {
            isPlaying: false,
            currentLevel: 1,
            health: 100,
            maxHealth: 100,
            ammo: 30,
            maxAmmo: 30,
            objectives: [
                { id: 1, text: "Enter the facility", completed: false },
                { id: 2, text: "Locate the server room", completed: false },
                { id: 3, text: "Download classified data", completed: false },
                { id: 4, text: "Escape the facility", completed: false }
            ],
            enemies: [],
            playerPosition: { x: 0, y: 1.6, z: 0 },
            playerRotation: { x: 0, y: 0 },
            moveDirection: { x: 0, z: 0 },
            isShooting: false,
            isJumping: false,
            lastShot: 0,
            shotCooldown: 200, // ms between shots
            moveSpeed: 0.1,
            lookSensitivity: 0.002,
            touchLookSensitivity: 0.05,
            gravity: 0.01,
            jumpForce: 0.2,
            velocity: { x: 0, y: 0, z: 0 },
            onGround: true,
            levelData: {
                1: {
                    name: "Infiltration",
                    description: "Enter the enemy compound and establish a foothold.",
                    startMessage: "Infiltrate the facility. Watch for guards.",
                    objectives: [
                        { id: 1, text: "Enter the facility", completed: false },
                        { id: 2, text: "Eliminate guards", completed: false },
                        { id: 3, text: "Secure the entrance", completed: false }
                    ]
                },
                2: {
                    name: "Server Room",
                    description: "Hack into the mainframe and extract classified data.",
                    startMessage: "Find the server room and download the data.",
                    objectives: [
                        { id: 1, text: "Locate the server room", completed: false },
                        { id: 2, text: "Hack the terminal", completed: false },
                        { id: 3, text: "Download classified data", completed: false },
                        { id: 4, text: "Defend position while downloading", completed: false }
                    ]
                },
                3: {
                    name: "Escape",
                    description: "Fight your way out as alarms blare throughout the facility.",
                    startMessage: "Alarms triggered! Find an escape route.",
                    objectives: [
                        { id: 1, text: "Reach the extraction point", completed: false },
                        { id: 2, text: "Eliminate pursuit team", completed: false },
                        { id: 3, text: "Escape via helicopter", completed: false }
                    ]
                }
            }
        };

        // DOM elements
        const mainMenu = document.getElementById('mainMenu');
        const levelSelect = document.getElementById('levelSelect');
        const controlsScreen = document.getElementById('controlsScreen');
        const gameUI = document.getElementById('gameUI');
        const pauseMenu = document.getElementById('pauseMenu');
        const missionComplete = document.getElementById('missionComplete');
        const missionFailed = document.getElementById('missionFailed');
        const pauseButton = document.getElementById('pauseButton');
        const healthBar = document.getElementById('healthBar');
        const currentAmmo = document.getElementById('currentAmmo');
        const maxAmmo = document.getElementById('maxAmmo');
        const missionInfo = document.getElementById('missionInfo');
        const missionText = document.getElementById('missionText');
        const objectivesPanel = document.getElementById('objectivesPanel');
        const objectivesList = document.getElementById('objectivesList');
        const damageOverlay = document.getElementById('damageOverlay');

        // Button event listeners
        document.getElementById('playButton').addEventListener('click', startGame);
        document.getElementById('levelSelectButton').addEventListener('click', showLevelSelect);
        document.getElementById('controlsButton').addEventListener('click', showControls);
        document.getElementById('backFromLevels').addEventListener('click', showMainMenu);
        document.getElementById('backFromControls').addEventListener('click', showMainMenu);
        document.getElementById('pauseButton').addEventListener('click', pauseGame);
        document.getElementById('resumeButton').addEventListener('click', resumeGame);
        document.getElementById('restartButton').addEventListener('click', restartLevel);
        document.getElementById('exitToMenuButton').addEventListener('click', exitToMenu);
        document.getElementById('nextMissionButton').addEventListener('click', nextMission);
        document.getElementById('replayMissionButton').addEventListener('click', restartLevel);
        document.getElementById('exitToMenuFromComplete').addEventListener('click', exitToMenu);
        document.getElementById('retryMissionButton').addEventListener('click', restartLevel);
        document.getElementById('exitToMenuFromFailed').addEventListener('click', exitToMenu);

        // Level selection
        document.querySelectorAll('.level-card:not(.locked)').forEach(card => {
            card.addEventListener('click', () => {
                gameState.currentLevel = parseInt(card.dataset.level);
                startGame();
            });
        });

        // Three.js setup
        let scene, camera, renderer;
        let geometry, material, mesh;
        let walls = [];
        let bullets = [];
        let enemies = [];
        let clock = new THREE.Clock();

        function initThreeJS() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0); // Eye height
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameCanvas').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Build level based on current level
            buildLevel(gameState.currentLevel);
            
            // Start animation loop
            animate();
        }

        function buildLevel(levelNum) {
            // Clear existing level objects
            walls.forEach(wall => scene.remove(wall));
            walls = [];
            
            enemies.forEach(enemy => scene.remove(enemy.mesh));
            enemies = [];
            
            // Create walls based on level
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.3
            });
            
            // Basic level layout - different for each level
            if (levelNum === 1) {
                // Level 1: Simple compound entrance
                
                // Outer walls
                createWall(-10, 1.5, 0, 1, 3, 20, wallMaterial); // Left wall
                createWall(10, 1.5, 0, 1, 3, 20, wallMaterial);  // Right wall
                createWall(0, 1.5, -10, 20, 3, 1, wallMaterial); // Back wall
                
                // Front wall with gap for entrance
                createWall(-7.5, 1.5, 10, 5, 3, 1, wallMaterial);
                createWall(7.5, 1.5, 10, 5, 3, 1, wallMaterial);
                
                // Interior structures
                createWall(-5, 1.5, 5, 1, 3, 8, wallMaterial);
                createWall(5, 1.5, 0, 1, 3, 10, wallMaterial);
                createWall(0, 1.5, -5, 8, 3, 1, wallMaterial);
                
                // Add some crates
                const crateGeometry = new THREE.BoxGeometry(1, 1, 1);
                const crateMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                
                for (let i = 0; i < 5; i++) {
                    const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                    crate.position.set(-8 + i * 0.7, 0.5, 8);
                    scene.add(crate);
                    walls.push(crate);
                }
                
                // Add enemies
                createEnemy(-3, 0, -3, 100);
                createEnemy(3, 0, -7, 100);
                createEnemy(7, 0, 5, 100);
                
                // Set player starting position
                gameState.playerPosition = { x: 0, y: 1.6, z: 8 };
                camera.position.set(0, 1.6, 8);
                
            } else if (levelNum === 2) {
                // Level 2: Server room complex
                
                // Outer walls
                createWall(-12, 1.5, 0, 1, 3, 24, wallMaterial); // Left wall
                createWall(12, 1.5, 0, 1, 3, 24, wallMaterial);  // Right wall
                createWall(0, 1.5, -12, 24, 3, 1, wallMaterial); // Back wall
                createWall(0, 1.5, 12, 24, 3, 1, wallMaterial);  // Front wall
                
                // Create doorway in front wall
                createWall(-9, 1.5, 12, 6, 3, 1, wallMaterial);
                createWall(9, 1.5, 12, 6, 3, 1, wallMaterial);
                
                // Interior corridors
                createWall(-6, 1.5, 6, 12, 3, 1, wallMaterial);
                createWall(6, 1.5, 6, 12, 3, 1, wallMaterial);
                createWall(-6, 1.5, 0, 1, 3, 12, wallMaterial);
                createWall(6, 1.5, 0, 1, 3, 12, wallMaterial);
                
                // Server room in the center
                createWall(-3, 1.5, -3, 1, 3, 6, wallMaterial);
                createWall(3, 1.5, -3, 1, 3, 6, wallMaterial);
                createWall(0, 1.5, -6, 6, 3, 1, wallMaterial);
                
                // Server racks
                const serverRackGeometry = new THREE.BoxGeometry(0.8, 2, 1.5);
                const serverRackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                for (let i = 0; i < 3; i++) {
                    const serverRack = new THREE.Mesh(serverRackGeometry, serverRackMaterial);
                    serverRack.position.set(-1.5 + i * 1.5, 1, -4);
                    scene.add(serverRack);
                    walls.push(serverRack);
                }
                
                // Add more enemies
                createEnemy(-8, 0, 8, 120);
                createEnemy(8, 0, 8, 120);
                createEnemy(-8, 0, -8, 120);
                createEnemy(8, 0, -8, 120);
                createEnemy(0, 0, -2, 150);
                
                // Set player starting position
                gameState.playerPosition = { x: 0, y: 1.6, z: 10 };
                camera.position.set(0, 1.6, 10);
                
            } else if (levelNum === 3) {
                // Level 3: Escape route
                
                // Complex maze-like structure for escape
                createWall(-15, 1.5, 0, 1, 3, 30, wallMaterial); // Left boundary
                createWall(15, 1.5, 0, 1, 3, 30, wallMaterial);  // Right boundary
                createWall(0, 1.5, -15, 30, 3, 1, wallMaterial); // Back boundary
                createWall(0, 1.5, 15, 30, 3, 1, wallMaterial);  // Front boundary
                
                // Interior maze walls
                createWall(-10, 1.5, 5, 10, 3, 1, wallMaterial);
                createWall(10, 1.5, 5, 10, 3, 1, wallMaterial);
                createWall(-5, 1.5, 10, 1, 3, 10, wallMaterial);
                createWall(5, 1.5, 10, 1, 3, 10, wallMaterial);
                createWall(-10, 1.5, -5, 10, 3, 1, wallMaterial);
                createWall(10, 1.5, -5, 10, 3, 1, wallMaterial);
                createWall(-5, 1.5, -10, 1, 3, 10, wallMaterial);
                createWall(5, 1.5, -10, 1, 3, 10, wallMaterial);
                
                // Central structure
                createWall(0, 1.5, 0, 8, 3, 8, wallMaterial);
                
                // Add more obstacles
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 28 - 14;
                    const z = Math.random() * 28 - 14;
                    
                    // Avoid placing obstacles in the player's starting area
                    if (Math.abs(x) < 3 && Math.abs(z - 10) < 3) continue;
                    
                    createWall(x, 1, z, 1, 2, 1, wallMaterial);
                }
                
                // Add many enemies
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 28 - 14;
                    const z = Math.random() * 28 - 14;
                    
                    // Avoid placing enemies in the player's starting area
                    if (Math.abs(x) < 5 && Math.abs(z - 10) < 5) continue;
                    
                    createEnemy(x, 0, z, 150);
                }
                
                // Set player starting position
                gameState.playerPosition = { x: 0, y: 1.6, z: 10 };
                camera.position.set(0, 1.6, 10);
            }
            
            // Update camera position
            camera.position.set(
                gameState.playerPosition.x,
                gameState.playerPosition.y,
                gameState.playerPosition.z
            );
        }

        function createWall(x, y, z, width, height, depth, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y, z);
            scene.add(wall);
            walls.push(wall);
            return wall;
        }

        function createEnemy(x, y, z, health) {
            // Enemy body
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Enemy head
            const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.1;
            
            // Group body and head
            const enemyMesh = new THREE.Group();
            enemyMesh.add(body);
            enemyMesh.add(head);
            
            enemyMesh.position.set(x, y + 0.9, z);
            scene.add(enemyMesh);
            
            const enemy = {
                mesh: enemyMesh,
                health: health,
                maxHealth: health,
                position: { x, y, z },
                state: 'idle', // idle, alert, attacking
                lastAction: 0,
                actionCooldown: 1000 + Math.random() * 1000,
                speed: 0.03
            };
            
            enemies.push(enemy);
            return enemy;
        }

        function createBullet(position, direction) {
            const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.position.copy(position);
            scene.add(bullet);
            
            bullets.push({
                mesh: bullet,
                direction: direction,
                speed: 0.5,
                lifetime: 100,
                fromPlayer: true
            });
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.mesh.position.x += bullet.direction.x * bullet.speed;
                bullet.mesh.position.y += bullet.direction.y * bullet.speed;
                bullet.mesh.position.z += bullet.direction.z * bullet.speed;
                
                bullet.lifetime--;
                
                // Check for collisions with walls
                let hitWall = false;
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);
                    
                    if (wallBox.intersectsBox(bulletBox)) {
                        hitWall = true;
                        break;
                    }
                }
                
                // Check for collisions with enemies if bullet is from player
                if (bullet.fromPlayer) {
                    for (const enemy of enemies) {
                        if (enemy.health <= 0) continue;
                        
                        const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);
                        const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);
                        
                        if (enemyBox.intersectsBox(bulletBox)) {
                            enemy.health -= 25; // Damage enemy
                            
                            // Enemy hit effect
                            enemy.mesh.children[0].material.color.set(0xffffff);
                            setTimeout(() => {
                                if (enemy.health > 0) {
                                    enemy.mesh.children[0].material.color.set(0xff0000);
                                }
                            }, 100);
                            
                            if (enemy.health <= 0) {
                                // Enemy death
                                enemy.state = 'dead';
                                scene.remove(enemy.mesh);
                                
                                // Check if all enemies are defeated
                                checkObjectiveCompletion();
                            }
                            
                            hitWall = true;
                            break;
                        }
                    }
                }
                
                // Check for collision with player if bullet is from enemy
                if (!bullet.fromPlayer) {
                    const playerBox = new THREE.Box3(
                        new THREE.Vector3(
                            camera.position.x - 0.3,
                            camera.position.y - 1.5,
                            camera.position.z - 0.3
                        ),
                        new THREE.Vector3(
                            camera.position.x + 0.3,
                            camera.position.y + 0.1,
                            camera.position.z + 0.3
                        )
                    );
                    
                    const bulletBox = new THREE.Box3().setFromObject(bullet.mesh);
                    
                    if (playerBox.intersectsBox(bulletBox)) {
                        takeDamage(10 + Math.floor(Math.random() * 10));
                        hitWall = true;
                    }
                }
                
                // Remove bullet if it hit something or expired
                if (hitWall || bullet.lifetime <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemies() {
            const playerPos = new THREE.Vector3(
                camera.position.x,
                camera.position.y - 1.6,
                camera.position.z
            );
            
            enemies.forEach(enemy => {
                if (enemy.health <= 0) return;
                
                const enemyPos = enemy.mesh.position;
                const distanceToPlayer = enemyPos.distanceTo(playerPos);
                
                // State machine for enemy behavior
                if (distanceToPlayer < 15) {
                    enemy.state = 'alert';
                    
                    // Face player
                    const direction = new THREE.Vector3(
                        playerPos.x - enemyPos.x,
                        0,
                        playerPos.z - enemyPos.z
                    ).normalize();
                    
                    const angle = Math.atan2(direction.x, direction.z);
                    enemy.mesh.rotation.y = angle;
                    
                    // Move towards player if not too close
                    if (distanceToPlayer > 5) {
                        enemyPos.x += direction.x * enemy.speed;
                        enemyPos.z += direction.z * enemy.speed;
                        
                        // Check for collisions with walls
                        const enemyBox = new THREE.Box3().setFromObject(enemy.mesh);
                        
                        for (const wall of walls) {
                            const wallBox = new THREE.Box3().setFromObject(wall);
                            
                            if (wallBox.intersectsBox(enemyBox)) {
                                // Move back
                                enemyPos.x -= direction.x * enemy.speed * 1.1;
                                enemyPos.z -= direction.z * enemy.speed * 1.1;
                                break;
                            }
                        }
                    }
                    
                    // Shoot at player
                    const now = Date.now();
                    if (now - enemy.lastAction > enemy.actionCooldown && distanceToPlayer < 10) {
                        enemy.lastAction = now;
                        
                        // Create bullet from enemy position towards player
                        const bulletPos = new THREE.Vector3(
                            enemyPos.x,
                            enemyPos.y + 1,
                            enemyPos.z
                        );
                        
                        const bulletDir = new THREE.Vector3(
                            playerPos.x - bulletPos.x,
                            playerPos.y - bulletPos.y,
                            playerPos.z - bulletPos.z
                        ).normalize();
                        
                        // Add some inaccuracy
                        bulletDir.x += (Math.random() - 0.5) * 0.1;
                        bulletDir.y += (Math.random() - 0.5) * 0.1;
                        bulletDir.z += (Math.random() - 0.5) * 0.1;
                        bulletDir.normalize();
                        
                        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                        
                        bullet.position.copy(bulletPos);
                        scene.add(bullet);
                        
                        bullets.push({
                            mesh: bullet,
                            direction: bulletDir,
                            speed: 0.4,
                            lifetime: 100,
                            fromPlayer: false
                        });
                    }
                } else {
                    enemy.state = 'idle';
                }
            });
        }

        function animate() {
            if (!gameState.isPlaying) return;
            
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update player movement
            updatePlayerMovement();
            
            // Update bullets
            updateBullets();
            
            // Update enemies
            updateEnemies();
            
            // Render scene
            renderer.render(scene, camera);
        }

        function updatePlayerMovement() {
            // Apply gravity
            if (!gameState.onGround) {
                gameState.velocity.y -= gameState.gravity;
            }
            
            // Update position based on velocity
            camera.position.y += gameState.velocity.y;
            
            // Check for ground collision
            if (camera.position.y < gameState.playerPosition.y) {
                camera.position.y = gameState.playerPosition.y;
                gameState.velocity.y = 0;
                gameState.onGround = true;
            }
            
            // Move player based on joystick input
            if (gameState.moveDirection.x !== 0 || gameState.moveDirection.z !== 0) {
                // Calculate movement vector relative to camera direction
                const angle = camera.rotation.y;
                const moveX = gameState.moveDirection.z * Math.sin(angle) + gameState.moveDirection.x * Math.cos(angle);
                const moveZ = gameState.moveDirection.z * Math.cos(angle) - gameState.moveDirection.x * Math.sin(angle);
                
                // Store current position
                const oldX = camera.position.x;
                const oldZ = camera.position.z;
                
                // Update position
                camera.position.x += moveX * gameState.moveSpeed;
                camera.position.z += moveZ * gameState.moveSpeed;
                
                // Check for collisions with walls
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(
                        camera.position.x - 0.3,
                        camera.position.y - 1.5,
                        camera.position.z - 0.3
                    ),
                    new THREE.Vector3(
                        camera.position.x + 0.3,
                        camera.position.y + 0.1,
                        camera.position.z + 0.3
                    )
                );
                
                let collision = false;
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    
                    if (wallBox.intersectsBox(playerBox)) {
                        collision = true;
                        break;
                    }
                }
                
                // If collision, revert position
                if (collision) {
                    camera.position.x = oldX;
                    camera.position.z = oldZ;
                }
            }
            
            // Handle shooting
            if (gameState.isShooting) {
                const now = Date.now();
                if (now - gameState.lastShot > gameState.shotCooldown && gameState.ammo > 0) {
                    gameState.lastShot = now;
                    gameState.ammo--;
                    
                    // Update ammo display
                    currentAmmo.textContent = gameState.ammo;
                    
                    // Create bullet
                    const bulletPos = new THREE.Vector3();
                    camera.getWorldPosition(bulletPos);
                    
                    const bulletDir = new THREE.Vector3();
                    camera.getWorldDirection(bulletDir);
                    
                    createBullet(bulletPos, bulletDir);
                    
                    // Add muzzle flash effect
                    // (simplified for this demo)
                }
            }
        }

        // Mobile controls setup
        function setupMobileControls() {
            const joystick = document.getElementById('joystick');
            const joystickThumb = document.getElementById('joystickThumb');
            const shootButton = document.getElementById('shootButton');
            const jumpButton = document.getElementById('jumpButton');
            
            // Joystick variables
            let joystickActive = false;
            let joystickOrigin = { x: 0, y: 0 };
            const joystickMaxRadius = 40;
            
            // Joystick touch events
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                joystickOrigin.x = touch.clientX - rect.left;
                joystickOrigin.y = touch.clientY - rect.top;
                joystickActive = true;
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;
                
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Calculate distance from origin
                const dx = x - joystickOrigin.x;
                const dy = y - joystickOrigin.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize and apply max radius
                const angle = Math.atan2(dy, dx);
                const limitedDistance = Math.min(distance, joystickMaxRadius);
                
                const thumbX = joystickOrigin.x + Math.cos(angle) * limitedDistance;
                const thumbY = joystickOrigin.y + Math.sin(angle) * limitedDistance;
                
                // Update thumb position
                joystickThumb.style.left = `${thumbX}px`;
                joystickThumb.style.top = `${thumbY}px`;
                
                // Update movement direction
                const normalizedX = Math.cos(angle) * (limitedDistance / joystickMaxRadius);
                const normalizedY = Math.sin(angle) * (limitedDistance / joystickMaxRadius);
                
                gameState.moveDirection.x = normalizedX;
                gameState.moveDirection.z = normalizedY;
            });
            
            const resetJoystick = () => {
                joystickActive = false;
                joystickThumb.style.left = '50%';
                joystickThumb.style.top = '50%';
                gameState.moveDirection.x = 0;
                gameState.moveDirection.z = 0;
            };
            
            joystick.addEventListener('touchend', resetJoystick);
            joystick.addEventListener('touchcancel', resetJoystick);
            
            // Shoot button
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameState.isShooting = true;
            });
            
            shootButton.addEventListener('touchend', () => {
                gameState.isShooting = false;
            });
            
            // Jump button
            jumpButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState.onGround) {
                    gameState.velocity.y = gameState.jumpForce;
                    gameState.onGround = false;
                }
            });
            
            // Look/aim control (anywhere on screen)
            let lastTouchX = 0;
            let lastTouchY = 0;
            let touchLookActive = false;
            
            document.addEventListener('touchstart', (e) => {
                // Ignore touches on control elements
                if (e.target.closest('.control-area')) return;
                
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                touchLookActive = true;
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!touchLookActive) return;
                
                // Ignore touches on control elements
                if (e.target.closest('.control-area')) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchX;
                const deltaY = touch.clientY - lastTouchY;
                
                // Rotate camera
                camera.rotation.y -= deltaX * gameState.touchLookSensitivity;
                
                // Limit vertical look
                gameState.playerRotation.x -= deltaY * gameState.touchLookSensitivity;
                gameState.playerRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, gameState.playerRotation.x));
                camera.rotation.x = gameState.playerRotation.x;
                
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            });
            
            document.addEventListener('touchend', (e) => {
                // Only reset if this was the touch used for looking
                if (touchLookActive && e.touches.length === 0) {
                    touchLookActive = false;
                }
            });
        }

        // Game state management functions
        function startGame() {
            mainMenu.classList.add('hidden');
            levelSelect.classList.add('hidden');
            controlsScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            
            gameState.isPlaying = true;
            gameState.health = gameState.maxHealth;
            gameState.ammo = gameState.maxAmmo;
            
            // Update UI
            healthBar.style.width = '100%';
            currentAmmo.textContent = gameState.ammo;
            maxAmmo.textContent = gameState.maxAmmo;
            
            // Initialize or reset Three.js scene
            if (!renderer) {
                initThreeJS();
                setupMobileControls();
            } else {
                buildLevel(gameState.currentLevel);
                
                // Reset player state
                gameState.velocity = { x: 0, y: 0, z: 0 };
                gameState.onGround = true;
                gameState.moveDirection = { x: 0, z: 0 };
                gameState.isShooting = false;
                
                // Start animation loop if it's not running
                if (!gameState.animationRunning) {
                    gameState.animationRunning = true;
                    animate();
                }
            }
            
            // Show mission info
            showMissionInfo(gameState.levelData[gameState.currentLevel].startMessage);
            
            // Set up objectives for this level
            setupObjectives(gameState.levelData[gameState.currentLevel].objectives);
            
            // Start the game loop
            gameState.animationRunning = true;
            animate();
        }

        function showLevelSelect() {
            mainMenu.classList.add('hidden');
            levelSelect.classList.remove('hidden');
        }

        function showControls() {
            mainMenu.classList.add('hidden');
            controlsScreen.classList.remove('hidden');
        }

        function showMainMenu() {
            mainMenu.classList.remove('hidden');
            levelSelect.classList.add('hidden');
            controlsScreen.classList.add('hidden');
            gameUI.classList.add('hidden');
            pauseMenu.classList.add('hidden');
            missionComplete.classList.add('hidden');
            missionFailed.classList.add('hidden');
            pauseButton.classList.add('hidden');
            
            gameState.isPlaying = false;
        }

        function pauseGame() {
            gameState.isPlaying = false;
            pauseMenu.classList.remove('hidden');
        }

        function resumeGame() {
            pauseMenu.classList.add('hidden');
            gameState.isPlaying = true;
            animate();
        }

        function restartLevel() {
            pauseMenu.classList.add('hidden');
            missionComplete.classList.add('hidden');
            missionFailed.classList.add('hidden');
            startGame();
        }

        function exitToMenu() {
            pauseMenu.classList.add('hidden');
            missionComplete.classList.add('hidden');
            missionFailed.classList.add('hidden');
            showMainMenu();
        }

        function nextMission() {
            missionComplete.classList.add('hidden');
            
            // Unlock next level if available
            if (gameState.currentLevel < 3) {
                gameState.currentLevel++;
                
                // Unlock the level in UI
                const nextLevelCard = document.querySelector(`.level-card[data-level="${gameState.currentLevel}"]`);
                if (nextLevelCard) {
                    nextLevelCard.classList.remove('locked');
                }
            }
            
            startGame();
        }

        function showMissionInfo(text) {
            missionText.textContent = text;
            missionInfo.classList.remove('hidden');
            
            // Hide after a few seconds
            setTimeout(() => {
                missionInfo.classList.add('hidden');
            }, 5000);
        }

        function setupObjectives(objectives) {
            // Clear existing objectives
            objectivesList.innerHTML = '';
            
            // Add new objectives
            objectives.forEach(objective => {
                const li = document.createElement('li');
                li.className = 'objective-item p-2 pl-3 text-sm';
                li.dataset.id = objective.id;
                li.textContent = objective.text;
                objectivesList.appendChild(li);
            });
            
            // Show objectives panel
            objectivesPanel.classList.remove('hidden');
        }

        function checkObjectiveCompletion() {
            // Example: Check if all enemies are defeated
            const allEnemiesDefeated = enemies.every(enemy => enemy.health <= 0);
            
            if (allEnemiesDefeated) {
                // Mark objective as completed
                const objectiveItem = document.querySelector('.objective-item[data-id="2"]');
                if (objectiveItem && !objectiveItem.classList.contains('completed')) {
                    objectiveItem.classList.add('completed');
                    showMissionInfo("Objective completed: All enemies eliminated");
                    
                    // For demo purposes, complete the mission after a delay
                    setTimeout(() => {
                        completeMission();
                    }, 3000);
                }
            }
        }

        function completeMission() {
            gameState.isPlaying = false;
            
            // Set mission stats
            document.getElementById('missionTime').textContent = '02:47';
            document.getElementById('missionAccuracy').textContent = '72%';
            document.getElementById('enemiesDefeated').textContent = `${enemies.length}/${enemies.length}`;
            
            // Show 3 stars for perfect completion
            document.getElementById('thirdStar').classList.remove('text-gray-600');
            document.getElementById('thirdStar').classList.add('text-yellow-400');
            
            document.getElementById('missionCompleteText').textContent = 
                `Mission "${gameState.levelData[gameState.currentLevel].name}" completed successfully!`;
            
            missionComplete.classList.remove('hidden');
        }

        function takeDamage(amount) {
            gameState.health -= amount;
            
            // Update health bar
            healthBar.style.width = `${Math.max(0, gameState.health / gameState.maxHealth * 100)}%`;
            
            // Show damage effect
            damageOverlay.style.opacity = '0.7';
            damageOverlay.style.border = '20px solid rgba(255,0,0,0.3)';
            
            setTimeout(() => {
                damageOverlay.style.opacity = '0';
                damageOverlay.style.border = '0px solid rgba(255,0,0,0.3)';
            }, 300);
            
            // Check if player is dead
            if (gameState.health <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameState.isPlaying = false;
            
            document.getElementById('failureReason').textContent = "Agent down. Mission failed.";
            
            missionFailed.classList.remove('hidden');
        }

        // Initialize the game
        window.addEventListener('load', () => {
            showMainMenu();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'947a624d04fb10dd',t:'MTc0ODU2Nzc2NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
