
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Space Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Arial', sans-serif;
            background-color: #000;
        }
        
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .hud {
            position: absolute;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            z-index: 10;
        }
        
        #score {
            top: 20px;
            left: 20px;
            font-size: 24px;
        }
        
        #health {
            top: 20px;
            right: 20px;
            font-size: 24px;
        }
        
        #speed-indicator {
            bottom: 20px;
            left: 20px;
            font-size: 20px;
        }
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        
        #restart-btn {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
        }
        
        .touch-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid #0ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            touch-action: none;
        }
        
        #boost-btn {
            background-color: rgba(255, 0, 0, 0.3);
            border-color: #f00;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            max-width: 80%;
        }
        
        #start-btn {
            background-color: #0ff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            #score, #health {
                font-size: 18px;
            }
            
            #speed-indicator {
                font-size: 16px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="score" class="hud">SCORE: 0</div>
    <div id="health" class="hud">SHIELD: 100%</div>
    <div id="speed-indicator" class="hud">SPEED: 1.0x</div>
    
    <div class="touch-controls">
        <div id="fire-btn" class="control-btn">ðŸ”¥</div>
        <div id="boost-btn" class="control-btn">âš¡</div>
    </div>
    
    <div id="game-over">
        <h2>GAME OVER</h2>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">RESTART</button>
    </div>
    
    <div id="instructions">
        <h2>SPACE EXPLORER</h2>
        <p>Navigate through the asteroid field and destroy targets</p>
        <h3>Controls:</h3>
        <p>Desktop: Mouse to steer, WASD to move, Space to fire</p>
        <p>Mobile: Tilt/drag to steer, touch buttons to fire/boost</p>
        <button id="start-btn">START MISSION</button>
    </div>

    <script>
        // Game variables
        let scene, camera, renderer, spaceship;
        let asteroids = [], targets = [], lasers = [];
        let score = 0;
        let health = 100;
        let gameActive = false;
        let speed = 1.0;
        let clock = new THREE.Clock();
        
        // Touch controls
        let touchControls = {
            touches: {},
            rotationSpeed: 0.003,
            isFiring: false,
            isBoosting: false
        };
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 0;
            camera.position.y = 0.5;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Add fog for depth perception
            scene.fog = new THREE.FogExp2(0x000011, 0.01);
            
            // Create spaceship
            createSpaceship();
            
            // Create starfield
            createStarfield();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Touch event listeners
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
            
            // Control buttons
            document.getElementById('fire-btn').addEventListener('touchstart', () => { touchControls.isFiring = true; });
            document.getElementById('fire-btn').addEventListener('touchend', () => { touchControls.isFiring = false; });
            document.getElementById('boost-btn').addEventListener('touchstart', () => { touchControls.isBoosting = true; });
            document.getElementById('boost-btn').addEventListener('touchend', () => { touchControls.isBoosting = false; });
            
            // Start button
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            // Restart button
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // Start animation loop
            animate();
        }
        
        function createSpaceship() {
            // Create a simple spaceship model
            const geometry = new THREE.ConeGeometry(0.5, 2, 8);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                emissive: 0x007777,
                shininess: 100
            });
            
            spaceship = new THREE.Mesh(geometry, material);
            spaceship.rotation.x = Math.PI / 2;
            
            // Add wings
            const wingGeometry = new THREE.BoxGeometry(3, 0.1, 0.7);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0088ff,
                emissive: 0x003366
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.z = -0.3;
            spaceship.add(wings);
            
            // Add cockpit
            const cockpitGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const cockpitMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x66ccff,
                emissive: 0x003366,
                transparent: true,
                opacity: 0.7
            });
            
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.z = 0.3;
            cockpit.position.y = 0.2;
            spaceship.add(cockpit);
            
            // Add engine glow
            const engineGlow = new THREE.PointLight(0x00ffff, 1, 5);
            engineGlow.position.z = -1;
            spaceship.add(engineGlow);
            
            // Create a group to hold the spaceship and camera
            const spaceshipGroup = new THREE.Group();
            spaceshipGroup.add(spaceship);
            spaceshipGroup.add(camera);
            
            // Position the spaceship relative to the camera
            spaceship.position.z = -2;
            spaceship.position.y = -0.5;
            
            scene.add(spaceshipGroup);
            
            // Store the group as the spaceship for easier reference
            spaceship = spaceshipGroup;
            
            // Add movement properties
            spaceship.userData = {
                velocity: new THREE.Vector3(0, 0, -1),
                rotationVelocity: new THREE.Vector2(0, 0),
                maxSpeed: 2.0,
                acceleration: 0.01,
                deceleration: 0.005,
                rotationSpeed: 0.05,
                rotationDamping: 0.95,
                movementControls: {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    up: false,
                    down: false
                },
                lastFireTime: 0,
                fireRate: 200 // ms between shots
            };
        }
        
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                sizeAttenuation: true
            });
            
            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
        
        function createAsteroid() {
            const size = Math.random() * 3 + 1;
            const geometry = new THREE.IcosahedronGeometry(size, 1);
            
            // Distort the geometry to make it look more like an asteroid
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const distortion = 0.4;
                positions.setX(i, x + (Math.random() - 0.5) * distortion * size);
                positions.setY(i, y + (Math.random() - 0.5) * distortion * size);
                positions.setZ(i, z + (Math.random() - 0.5) * distortion * size);
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0x888888 : 0x777755,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const asteroid = new THREE.Mesh(geometry, material);
            
            // Position the asteroid
            const distance = 100;
            const angle = Math.random() * Math.PI * 2;
            const height = (Math.random() - 0.5) * 50;
            
            asteroid.position.x = Math.sin(angle) * distance;
            asteroid.position.y = height;
            asteroid.position.z = Math.cos(angle) * distance;
            
            // Add rotation and movement
            asteroid.userData = {
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.2
                ),
                size: size
            };
            
            scene.add(asteroid);
            asteroids.push(asteroid);
            
            // Limit the number of asteroids
            if (asteroids.length > 50) {
                const oldAsteroid = asteroids.shift();
                scene.remove(oldAsteroid);
            }
        }
        
        function createTarget() {
            // Create a target (a glowing cube)
            const geometry = new THREE.BoxGeometry(3, 3, 3);
            const material = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0x660000,
                shininess: 50
            });
            
            const target = new THREE.Mesh(geometry, material);
            
            // Add a point light to make it glow
            const light = new THREE.PointLight(0xff0000, 1, 10);
            target.add(light);
            
            // Position the target
            const distance = 150;
            const angle = Math.random() * Math.PI * 2;
            const height = (Math.random() - 0.5) * 40;
            
            target.position.x = Math.sin(angle) * distance;
            target.position.y = height;
            target.position.z = Math.cos(angle) * distance;
            
            // Add rotation
            target.userData = {
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.01,
                    y: 0.02,
                    z: (Math.random() - 0.5) * 0.01
                },
                points: 100
            };
            
            scene.add(target);
            targets.push(target);
            
            // Limit the number of targets
            if (targets.length > 10) {
                const oldTarget = targets.shift();
                scene.remove(oldTarget);
            }
        }
        
        function fireLaser() {
            const now = Date.now();
            if (now - spaceship.userData.lastFireTime < spaceship.userData.fireRate) {
                return;
            }
            
            spaceship.userData.lastFireTime = now;
            
            // Create a laser beam
            const geometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
            const material = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            
            const laser = new THREE.Mesh(geometry, material);
            
            // Position the laser in front of the spaceship
            laser.position.copy(spaceship.position);
            laser.rotation.copy(spaceship.rotation);
            
            // Adjust position to start from the front of the ship
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(spaceship.quaternion);
            
            laser.position.add(direction.multiplyScalar(3));
            laser.rotation.x = Math.PI / 2;
            
            // Add a point light to make it glow
            const light = new THREE.PointLight(0x00ffff, 1, 5);
            laser.add(light);
            
            // Set velocity based on spaceship's direction
            const velocity = new THREE.Vector3(0, 0, -1);
            velocity.applyQuaternion(spaceship.quaternion);
            velocity.multiplyScalar(3); // Laser speed
            
            laser.userData = {
                velocity: velocity,
                lifeTime: 2000, // ms
                createdAt: Date.now()
            };
            
            scene.add(laser);
            lasers.push(laser);
            
            // Play laser sound
            playSound('laser');
        }
        
        function updateSpaceship(delta) {
            const userData = spaceship.userData;
            
            // Apply rotation based on mouse/touch input
            spaceship.rotation.y += userData.rotationVelocity.x;
            spaceship.rotation.x += userData.rotationVelocity.y;
            
            // Clamp vertical rotation to prevent flipping
            spaceship.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, spaceship.rotation.x));
            
            // Apply damping to rotation
            userData.rotationVelocity.x *= userData.rotationDamping;
            userData.rotationVelocity.y *= userData.rotationDamping;
            
            // Apply movement controls
            const acceleration = userData.acceleration * delta * 60;
            const currentSpeed = userData.velocity.length();
            
            // Forward/backward movement
            if (userData.movementControls.forward) {
                userData.velocity.z -= acceleration;
            }
            if (userData.movementControls.backward) {
                userData.velocity.z += acceleration;
            }
            
            // Left/right movement
            if (userData.movementControls.left) {
                userData.velocity.x -= acceleration;
            }
            if (userData.movementControls.right) {
                userData.velocity.x += acceleration;
            }
            
            // Up/down movement
            if (userData.movementControls.up) {
                userData.velocity.y += acceleration;
            }
            if (userData.movementControls.down) {
                userData.velocity.y -= acceleration;
            }
            
            // Apply boost
            if (touchControls.isBoosting) {
                speed = Math.min(speed + 0.05, 3.0);
            } else {
                speed = Math.max(speed - 0.02, 1.0);
            }
            
            // Update speed indicator
            document.getElementById('speed-indicator').textContent = `SPEED: ${speed.toFixed(1)}x`;
            
            // Apply natural deceleration
            const deceleration = userData.deceleration * delta * 60;
            userData.velocity.x *= (1 - deceleration);
            userData.velocity.y *= (1 - deceleration);
            userData.velocity.z *= (1 - deceleration);
            
            // Limit maximum speed
            const maxSpeed = userData.maxSpeed * speed;
            if (currentSpeed > maxSpeed) {
                userData.velocity.normalize().multiplyScalar(maxSpeed);
            }
            
            // Move the spaceship
            spaceship.position.add(userData.velocity);
            
            // Fire laser if needed
            if (touchControls.isFiring) {
                fireLaser();
            }
        }
        
        function updateAsteroids() {
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                
                // Rotate the asteroid
                asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                
                // Move the asteroid
                asteroid.position.add(asteroid.userData.velocity);
                
                // Check if asteroid is too far away
                if (asteroid.position.distanceTo(spaceship.position) > 200) {
                    scene.remove(asteroid);
                    asteroids.splice(i, 1);
                }
                
                // Check collision with spaceship
                if (gameActive && asteroid.position.distanceTo(spaceship.position) < asteroid.userData.size + 1) {
                    // Collision detected
                    health -= Math.floor(asteroid.userData.size * 10);
                    document.getElementById('health').textContent = `SHIELD: ${Math.max(0, health)}%`;
                    
                    // Play collision sound
                    playSound('hit');
                    
                    // Visual feedback
                    asteroid.material.emissive.setHex(0xff0000);
                    setTimeout(() => {
                        if (asteroid.material) {
                            asteroid.material.emissive.setHex(0x000000);
                        }
                    }, 200);
                    
                    // Check if game over
                    if (health <= 0) {
                        gameOver();
                    }
                }
            }
        }
        
        function updateTargets() {
            for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                
                // Rotate the target
                target.rotation.x += target.userData.rotationSpeed.x;
                target.rotation.y += target.userData.rotationSpeed.y;
                target.rotation.z += target.userData.rotationSpeed.z;
                
                // Check if target is too far away
                if (target.position.distanceTo(spaceship.position) > 200) {
                    scene.remove(target);
                    targets.splice(i, 1);
                }
            }
        }
        
        function updateLasers() {
            const now = Date.now();
            
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                
                // Move the laser
                laser.position.add(laser.userData.velocity);
                
                // Check if laser has expired
                if (now - laser.userData.createdAt > laser.userData.lifeTime) {
                    scene.remove(laser);
                    lasers.splice(i, 1);
                    continue;
                }
                
                // Check collision with asteroids
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];
                    if (laser.position.distanceTo(asteroid.position) < asteroid.userData.size) {
                        // Collision detected
                        scene.remove(laser);
                        lasers.splice(i, 1);
                        
                        // Visual feedback
                        asteroid.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            if (asteroid.material) {
                                asteroid.material.emissive.setHex(0x000000);
                            }
                        }, 200);
                        
                        // Play explosion sound
                        playSound('explosion');
                        
                        // Add score based on asteroid size
                        if (gameActive) {
                            score += Math.floor(asteroid.userData.size * 5);
                            document.getElementById('score').textContent = `SCORE: ${score}`;
                        }
                        
                        break;
                    }
                }
                
                // Check collision with targets
                for (let j = targets.length - 1; j >= 0; j--) {
                    const target = targets[j];
                    if (laser.position.distanceTo(target.position) < 2) {
                        // Collision detected
                        scene.remove(laser);
                        lasers.splice(i, 1);
                        
                        // Remove the target
                        scene.remove(target);
                        targets.splice(j, 1);
                        
                        // Play explosion sound
                        playSound('explosion');
                        
                        // Add score
                        if (gameActive) {
                            score += target.userData.points;
                            document.getElementById('score').textContent = `SCORE: ${score}`;
                        }
                        
                        // Create explosion effect
                        createExplosion(target.position);
                        
                        break;
                    }
                }
            }
        }
        
        function createExplosion(position) {
            // Create particle system for explosion
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.5,
                transparent: true,
                opacity: 1
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.copy(position);
            
            // Set velocities for particles
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                velocities.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: (Math.random() - 0.5) * 0.3,
                    z: (Math.random() - 0.5) * 0.3
                });
            }
            
            particles.userData = {
                velocities: velocities,
                lifeTime: 1000,
                createdAt: Date.now()
            };
            
            scene.add(particles);
            
            // Add a point light for the explosion
            const light = new THREE.PointLight(0xff5500, 2, 10);
            light.position.copy(position);
            scene.add(light);
            
            // Remove the light after a short time
            setTimeout(() => {
                scene.remove(light);
            }, 500);
            
            // Update and remove particles
            const updateExplosion = () => {
                const now = Date.now();
                const positions = particles.geometry.attributes.position.array;
                
                // Update particle positions
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] += velocities[i].x;
                    positions[i3 + 1] += velocities[i].y;
                    positions[i3 + 2] += velocities[i].z;
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                // Fade out
                const elapsed = now - particles.userData.createdAt;
                const opacity = 1 - (elapsed / particles.userData.lifeTime);
                particles.material.opacity = Math.max(0, opacity);
                
                // Remove when done
                if (elapsed < particles.userData.lifeTime) {
                    requestAnimationFrame(updateExplosion);
                } else {
                    scene.remove(particles);
                }
            };
            
            updateExplosion();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (gameActive) {
                // Update spaceship
                updateSpaceship(delta);
                
                // Update game objects
                updateAsteroids();
                updateTargets();
                updateLasers();
                
                // Spawn new objects
                if (Math.random() < 0.02) {
                    createAsteroid();
                }
                
                if (Math.random() < 0.005) {
                    createTarget();
                }
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseMove(event) {
            if (!gameActive) return;
            
            // Calculate normalized device coordinates
            const ndcX = (event.clientX / window.innerWidth) * 2 - 1;
            const ndcY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Apply rotation based on mouse position
            spaceship.userData.rotationVelocity.x = -ndcX * spaceship.userData.rotationSpeed;
            spaceship.userData.rotationVelocity.y = -ndcY * spaceship.userData.rotationSpeed;
        }
        
        function onKeyDown(event) {
            if (!gameActive) return;
            
            switch (event.key.toLowerCase()) {
                case 'w':
                    spaceship.userData.movementControls.forward = true;
                    break;
                case 's':
                    spaceship.userData.movementControls.backward = true;
                    break;
                case 'a':
                    spaceship.userData.movementControls.left = true;
                    break;
                case 'd':
                    spaceship.userData.movementControls.right = true;
                    break;
                case 'q':
                    spaceship.userData.movementControls.up = true;
                    break;
                case 'e':
                    spaceship.userData.movementControls.down = true;
                    break;
                case ' ':
                    fireLaser();
                    break;
                case 'shift':
                    touchControls.isBoosting = true;
                    break;
            }
        }
        
        function onKeyUp(event) {
            if (!gameActive) return;
            
            switch (event.key.toLowerCase()) {
                case 'w':
                    spaceship.userData.movementControls.forward = false;
                    break;
                case 's':
                    spaceship.userData.movementControls.backward = false;
                    break;
                case 'a':
                    spaceship.userData.movementControls.left = false;
                    break;
                case 'd':
                    spaceship.userData.movementControls.right = false;
                    break;
                case 'q':
                    spaceship.userData.movementControls.up = false;
                    break;
                case 'e':
                    spaceship.userData.movementControls.down = false;
                    break;
                case 'shift':
                    touchControls.isBoosting = false;
                    break;
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            
            if (!gameActive) return;
            
            // Store all active touches
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                
                // Check if touch is on a control button
                const fireBtn = document.getElementById('fire-btn');
                const boostBtn = document.getElementById('boost-btn');
                const fireRect = fireBtn.getBoundingClientRect();
                const boostRect = boostBtn.getBoundingClientRect();
                
                if (touch.clientX >= fireRect.left && touch.clientX <= fireRect.right &&
                    touch.clientY >= fireRect.top && touch.clientY <= fireRect.bottom) {
                    // Touch on fire button
                    touchControls.isFiring = true;
                } else if (touch.clientX >= boostRect.left && touch.clientX <= boostRect.right &&
                           touch.clientY >= boostRect.top && touch.clientY <= boostRect.bottom) {
                    // Touch on boost button
                    touchControls.isBoosting = true;
                } else {
                    // Touch for steering
                    touchControls.touches[touch.identifier] = {
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            
            if (!gameActive) return;
            
            // Update touch positions
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                
                if (touchControls.touches[touch.identifier]) {
                    touchControls.touches[touch.identifier].currentX = touch.clientX;
                    touchControls.touches[touch.identifier].currentY = touch.clientY;
                    
                    // Calculate movement for this touch
                    const touchData = touchControls.touches[touch.identifier];
                    const deltaX = touchData.currentX - touchData.startX;
                    const deltaY = touchData.currentY - touchData.startY;
                    
                    // Apply rotation based on touch movement
                    spaceship.userData.rotationVelocity.x = -deltaX * touchControls.rotationSpeed;
                    spaceship.userData.rotationVelocity.y = -deltaY * touchControls.rotationSpeed;
                    
                    // Update start position for smoother control
                    touchData.startX = touchData.currentX;
                    touchData.startY = touchData.currentY;
                }
            }
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            
            if (!gameActive) return;
            
            // Remove ended touches
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                
                // Check if touch was on a control button
                const fireBtn = document.getElementById('fire-btn');
                const boostBtn = document.getElementById('boost-btn');
                const fireRect = fireBtn.getBoundingClientRect();
                const boostRect = boostBtn.getBoundingClientRect();
                
                if (touch.clientX >= fireRect.left && touch.clientX <= fireRect.right &&
                    touch.clientY >= fireRect.top && touch.clientY <= fireRect.bottom) {
                    // Released fire button
                    touchControls.isFiring = false;
                } else if (touch.clientX >= boostRect.left && touch.clientX <= boostRect.right &&
                           touch.clientY >= boostRect.top && touch.clientY <= boostRect.bottom) {
                    // Released boost button
                    touchControls.isBoosting = false;
                } else {
                    // Released steering touch
                    delete touchControls.touches[touch.identifier];
                }
            }
        }
        
        function startGame() {
            document.getElementById('instructions').style.display = 'none';
            gameActive = true;
            
            // Reset game state
            score = 0;
            health = 100;
            document.getElementById('score').textContent = `SCORE: ${score}`;
            document.getElementById('health').textContent = `SHIELD: ${health}%`;
            
            // Create initial objects
            for (let i = 0; i < 20; i++) {
                createAsteroid();
            }
            
            for (let i = 0; i < 5; i++) {
                createTarget();
            }
            
            // Enable device orientation for mobile if available
            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                        }
                    })
                    .catch(console.error);
            } else if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
            }
        }
        
        function handleDeviceOrientation(event) {
            if (!gameActive) return;
            
            // Use device orientation for steering on mobile
            const beta = event.beta; // -180 to 180 (front/back tilt)
            const gamma = event.gamma; // -90 to 90 (left/right tilt)
            
            if (beta !== null && gamma !== null) {
                // Apply rotation based on device orientation
                spaceship.userData.rotationVelocity.y = -(beta - 45) / 45 * spaceship.userData.rotationSpeed;
                spaceship.userData.rotationVelocity.x = -gamma / 45 * spaceship.userData.rotationSpeed;
            }
        }
        
        function gameOver() {
            gameActive = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
            
            // Remove device orientation listener if it was added
            window.removeEventListener('deviceorientation', handleDeviceOrientation);
        }
        
        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            
            // Clear existing objects
            for (let i = asteroids.length - 1; i >= 0; i--) {
                scene.remove(asteroids[i]);
            }
            asteroids = [];
            
            for (let i = targets.length - 1; i >= 0; i--) {
                scene.remove(targets[i]);
            }
            targets = [];
            
            for (let i = lasers.length - 1; i >= 0; i--) {
                scene.remove(lasers[i]);
            }
            lasers = [];
            
            // Reset spaceship position
            spaceship.position.set(0, 0, 0);
            spaceship.rotation.set(0, 0, 0);
            spaceship.userData.velocity.set(0, 0, -1);
            spaceship.userData.rotationVelocity.set(0, 0);
            
            // Start a new game
            startGame();
        }
        
        function playSound(type) {
            // Simple audio feedback using Web Audio API
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch (type) {
                case 'laser':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                    
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                    
                case 'hit':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'947a96d395104de2',t:'MTc0ODU2OTkxNS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
