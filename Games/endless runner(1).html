<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>3D Endless Runner</title> <style> body {margin:0;overflow:hidden;background:#000;} canvas {display:block;} #overlay { position:absolute;top:0;left:0;width:100%;height:100%; touch-action:none; } </style> </head> <body> <canvas id="game"></canvas> <div id="overlay"></div> <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script> <script> const canvas=document.getElementById('game'); const renderer=new THREE.WebGLRenderer({canvas}); renderer.setSize(window.innerWidth,window.innerHeight); const scene=new THREE.Scene(); scene.background=new THREE.Color(0x202020); const camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000); camera.position.set(0,2,5); const light=new THREE.DirectionalLight(0xffffff,1); light.position.set(0,10,10); scene.add(light); const ambient=new THREE.AmbientLight(0x404040); scene.add(ambient); const playerGeo=new THREE.BoxGeometry(1,1,1); const playerMat=new THREE.MeshStandardMaterial({color:0x00ff00}); const player=new THREE.Mesh(playerGeo,playerMat); player.position.y=0.5; scene.add(player); const groundGeo=new THREE.BoxGeometry(10,0.1,100); const groundMat=new THREE.MeshStandardMaterial({color:0x333333}); const ground=new THREE.Mesh(groundGeo,groundMat); ground.position.z=-50; scene.add(ground); let obstacles=[]; let obstacleCount=0; function createObstacle(z){ obstacleCount++; let type; if(obstacleCount%10===0){ type=3; // full-width obstacle 
} else { type=Math.floor(Math.random()*3); } let geo,mat,color; if(type===0){ // normal block 
geo=new THREE.BoxGeometry(1,1,1); color=0xff0000; } else if(type===1){ // low obstacle (jump over) 
geo=new THREE.BoxGeometry(1,0.5,1); color=0xffff00; } else if(type===2){ // high obstacle (slide under) 
geo=new THREE.BoxGeometry(1,2,1); color=0x0000ff; } else { // full-width obstacle 
geo=new THREE.BoxGeometry(3,1,1); color=0xff00ff; } mat=new THREE.MeshStandardMaterial({color}); const obs=new THREE.Mesh(geo,mat); obs.userData.type=type; if(type===3){ obs.position.set(0,geo.parameters.height/2,z); } else { obs.position.set((Math.floor(Math.random()*3)-1)*2,geo.parameters.height/2,z); } scene.add(obs); obstacles.push(obs); } let speed=0.2; let lane=0; let jump=false; let slide=false; let jumpVel=0; let score=0; let nextSpeedUp=500; function resetObstacle(obs){ obs.position.z-=100; obstacleCount++; let type; if(obstacleCount%10===0){ type=3; } else { type=Math.floor(Math.random()*3); } obs.userData.type=type; if(type===0){obs.scale.set(1,1,1);obs.material.color.set(0xff0000);} if(type===1){obs.scale.set(1,0.5,1);obs.material.color.set(0xffff00);} if(type===2){obs.scale.set(1,2,1);obs.material.color.set(0x0000ff);} if(type===3){obs.scale.set(6,1,1);obs.material.color.set(0xff00ff);} obs.position.x=(type===3)?0:(Math.floor(Math.random()*3)-1)*2; obs.position.y=obs.scale.y/2; } for(let i=0;i<10;i++) createObstacle(-i*10-10); function update(){ player.position.x=THREE.MathUtils.lerp(player.position.x,lane*2,0.2); if(jump){ player.position.y+=jumpVel; jumpVel-=0.03; if(player.position.y<=0.5){ player.position.y=0.5; jump=false; } } if(slide){ player.scale.y=0.5; } else { player.scale.y=1; } obstacles.forEach(o=>{ o.position.z+=speed; if(o.position.z>5) resetObstacle(o); const dz=Math.abs(o.position.z-player.position.z); const dx=Math.abs(o.position.x-player.position.x); const type=o.userData.type; if(dz<1){ if(type===3 && player.position.y<1 && !slide){ gameOver(); } else if(type===0 && dx<1 && player.position.y<1 && !slide){ gameOver(); } else if(type===1 && dx<1 && player.position.y<1){ gameOver(); } else if(type===2 && dx<1 && !slide){ gameOver(); } } }); score+=speed; if(score>nextSpeedUp){ speed+=0.05; nextSpeedUp+=500; } camera.position.z=player.position.z+5; camera.lookAt(player.position.x,player.position.y,player.position.z); } function gameOver(){ alert("Game Over! Score: "+Math.floor(score)); window.location.reload(); } function loop(){ update(); renderer.render(scene,camera); requestAnimationFrame(loop); } loop(); window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }); const overlay=document.getElementById('overlay'); let startX=null,startY=null; overlay.addEventListener('touchstart',e=>{ startX=e.touches[0].clientX; startY=e.touches[0].clientY; }); overlay.addEventListener('touchend',e=>{ const endX=e.changedTouches[0].clientX; const endY=e.changedTouches[0].clientY; const diffX=endX-startX; const diffY=endY-startY; if(Math.abs(diffX)>Math.abs(diffY)){ if(Math.abs(diffX)>50){ if(diffX>0 && lane<1) lane++; else if(diffX<0 && lane>-1) lane--; } } else { if(diffY<-50 && !jump){ // swipe up 
jump=true; jumpVel=0.5; } else if(diffY>50){ // swipe down 
slide=true; setTimeout(()=>slide=false,600); } } }); </script> </body> </html>